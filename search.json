[{"title":"进制转换","url":"/2024/01/06/进制转换/","content":"## 题目：\n用天平称重时，我们希望用尽可能少的砝码组合称出尽可能多的重量。\n        如果只有5个砝码，重量分别是1，3，9，27，81\n        则它们可以组合称出1到121之间任意整数重量（砝码允许放在左右两个盘中）。\n <!--more-->\n本题目要求编程实现：对用户给定的重量，给出砝码组合方案。\n例如：\n用户输入：\n5\n程序输出：\n9-3-1\n用户输入：\n19\n程序输出：\n27-9+1\n\n要求程序输出的组合总是大数在前小数在后。\n可以假设用户的输入的数字符合范围1~121。\n\n\n## 思路：\n观察输出，都是3的多少次方，所以我们可以把输入的值，转换成3进制的数,因为3进制转10进制\n            每一项都是ai\\*3^n,就满足题目的要求了，就比如 4 = 1\\*(3^1) +1\\*(3^0) =3+1 ，但是 5 使用除K取余法时，会余2，我们不能余2，\n            因为，每一项的系数ai都应该为 0 或 1 或 -1，所以在除k取余，我们只要把余数2变成-1，就行了。\n\n\n## 代码：\n```java\npublic class Test2 {\n   public static void main(String[] args) {\n       String weight = JOptionPane.showInputDialog(\"请输入重量\");\n       balance(weight);\n   }\n    private static void balance(String w) {\n       //n为当前被除数\n        int n = Integer.parseInt(w);\n        ArrayList<Integer> nums = new ArrayList<>();\n        int i = 0;\n        while (n != 0){\n            nums.add(i,n % 3);\n            n = n / 3;\n            if (nums.get(i) == 2){\n                //替换当前位置的数\n                nums.set(i,-1);\n                n += 1;\n            }\n            i++;\n        }\n        System.out.println(nums);\n        for (int j = nums.size() - 1 ; j >= 0; j--){\n            if (nums.get(j) < 0 || j == nums.size()-1){\n                System.out.print((int)Math.pow(3,j)*nums.get(j));\n            } else if (nums.get(j) == 0){\n\n            } else{\n                System.out.print(\"+\"+(int)Math.pow(3,j)*nums.get(j));\n            }\n        }\n\n    }\n}\n\n```","tags":["进制转换"],"categories":["算法"]},{"title":"组合算法","url":"/2024/01/06/组合算法/","content":"在数学中，我们学习了，排列组合，排列是有序的，组合是无顺序的。在做算法题时，我们也会遇到这种。\nso，今天来理下，怎么写组合。\n<!--more-->\n举个例子，桌子上有3个球A,B,C，我们取2个，无放回的取，有几种情况？算一下：也就是C(3,2)=3。\n\n### 需要解决的问题\n那么先理下思路，我们需要解决哪几个问题：\n1. 要怎么表示3个数是否被取了呢，我想，弄一个int数组把他们的初值置为0，就像`int a = {0,0,0}`,如果他被取了，就把它置为1，三个int分别代表ABC。\n2. 然后就是从箱子里取球,是组合是吧。\n3. 最后，满足条件，输出我们得到的组合。\n\n### 方案\n第一步，我们已经解决了，怎么表示球被取出来了。\n第二步，组合：\n我们想下，以下场景：\n   - 从桌子上取A，那么就是BC求组合，取B，就是AC求组合，取C，就是AB求组合\n   - 继续重复，求BC的组合，就是取B出来，求C的组合，再像这样继续套娃。。。。都是调用的同一个方法，可想而知，是一个递归。\n\n那么定义一个函数，它的作用是**从a中取球，取到满足条件输出组合**。再定义一个index，表示我取得是哪一个球。之后，我们取球，如果要选，把a[index]置为1，参数curr表示已经取了多少个球，所以也需要+1，然后再去取下一个球。如此反复。\n\n当然我们也可以不取这个球，不取这个球，就要把它置为0，但是需要index++，因为不取这个球，那还是需要去取下一个球，比如不取A，但是我们还是要去BC。\n\n\n紧接着找到递归出口，也就是取完2个球，或者3个球都被取完了。得到之后，就把它打印出来。也就是调用show(a[])方法。\n\nshow方法:遍历i数组，如果a[i]==1，即我们取了，就把他输出。`(char)('A'+i)+\" \"`这也是个小细节。\n\n\n## 代码\n\n```java\n/*从5个小球中取出三个小球*/\npublic class 组合 {\n    static int count;\n    //很明显是一个组合问题,不用考虑排列，排列的话，就可以用全排列\n    public static void main(String[] args) {\n        int a[] = {0,0,0};\n        method1(a,0,2,0);\n        System.out.println(count);\n    }\n\n    /**\n     * 作用: 从a中取球，取到2个球有哪几种组合\n     *\n     * @param a 数组a表示当前被选中的数\n     * @param index 当前被选中的数的索引\n     * @param sum  要选中多少个数\n     * @param curr  当前已经选中了多少个数\n     */\n    private static void method1(int a[], int index, int sum, int curr) {\n        if (curr == sum){\n            show(a);\n            count++;\n            return;\n        }\n        //如果数组都选完了，就不能选了,之所以index == a.length，是因为最后一个也要被选\n        if (index == a.length){\n            return;\n        }\n        //当前位置要选，将这个位置改为1\n        a[index] = 1;\n        //判断下一个数是否要选\n        method1(a,index+1,sum,curr+1);\n        //当前这个位置不选，将这个位置改为0\n        a[index] = 0;\n        method1(a,index+1,sum,curr);\n\n    }\n\n    private static void show(int[] a) {\n        for (int i =0; i < a.length;i++){\n            if (a[i] == 1 ){\n                System.out.print((char)('A'+i)+\" \");//变成char与int相加为int，所以再把它变成char\n            }\n        }\n        System.out.println();\n    }\n}\n\n```\n\n","tags":["递归","组合"],"categories":["算法","递归"]},{"title":"罗马数字转十进制的三种方法","url":"/2024/01/06/罗马数字转十进制的三种方法/","content":"## 题目要求\n> 古罗马帝国开创了辉煌的人类文明，但他们的数字表示法的确有些繁琐，尤其在表示大数的时候，现在看起来简直不能忍受，所以在现代很少使用了。\n<!--more-->\n之所以这样，不是因为发明表示法的人的智力的问题，而是因为一个宗教的原因，当时的宗教禁止在数字中出现0的概念！\n罗马数字的表示主要依赖以下几个基本符号：\nI –> 1\nV –> 5\nX –> 10\nL –> 50\nC –> 100\nD –> 500\nM –> 1000\n这里，我们只介绍一下1000以内的数字的表示法。\n单个符号重复多少次，就表示多少倍。最多重复3次。\n比如：CCC表示300 XX表示20，但150并不用LLL表示，这个规则仅适用于I X C M。\n如果相邻级别的大单位在右，小单位在左，表示大单位中扣除小单位。\n比如：IX表示9 IV表示4 XL表示40 \n49 = XLIX\n更多的示例参见下表，你找到规律了吗？ \nI = 1 \nII = 2\nIII = 3\nIV = 4\nV = 5\nVI = 6\nVII = 7\nVIII = 8\nIX = 9 \nX = 10\nXI = 11\nXII = 12\nXIII = 13\nXIV = 14\nXV = 15\nXVI = 16\nXVII = 17\nXVIII = 18\nXIX = 19\nXX = 20\nXXI = 21\nXXII = 22\nXXIX = 29\nXXX = 30\nXXXIV = 34\nXXXV = 35\nXXXIX = 39\nXL = 40\nL = 50\nLI = 51\nLV = 55\nLX = 60\nLXV = 65\nLXXX = 80\nXC = 90\nXCIII = 93\nXCV = 95\nXCVIII = 98\nXCIX = 99\nC = 100\nCC = 200\nCCC = 300\nCD = 400\nD = 500\nDC = 600\nDCC = 700\nDCCC = 800\nCM = 900\nCMXCIX = 999\n本题目的要求是：请编写程序，由用户输入若干个罗马数字串，程序输出对应的十进制表示。\n输入格式是：第一行是整数n,表示接下来有n个罗马数字(n<100)。\n以后每行一个罗马数字。罗马数字大小不超过999。\n要求程序输出n行，就是罗马数字对应的十进制数据。\n例如，用户输入：\n3\nLXXX\nXCIII\nDCCII\n则程序应该输出：\n80\n93\n702\n\n## 解法\n全在程序里，分为三个方法，三个方法由易到难。但全是暴力求解法。\n1. 直接找出组成相减的字符串，先把加法算完，再算减法。\n2. 遍历字符串，根据它的转换规则\n\t* **相邻的罗马数字相加。**\n\t* **相邻的罗马数字，左边小于右边的数字，等于右 - 左。**\n4. 思路和法二一样，但是算法上简洁了。\n```java\nimport java.util.*;\n\n/*本题目的要求是：请编写程序，由用户输入若干个罗马数字串，程序输出对应的十进制表示。\n        输入格式是：第一行是整数n,表示接下来有n个罗马数字(n<100)。\n        以后每行一个罗马数字。罗马数字大小不超过999。\n        要求程序输出n行，就是罗马数字对应的十进制数据。*/\npublic class Test3 {\n    public static void main(String[] args) {\n        method1(\"XCV\");\n//        method2(\"XCV\");\n//        method3(\"XCV\");\n    }\n    //直接找出组成相减的字符串\n    private static void method1(String lm) {\n        int sum =0;\n        //遍历字符串，如果存在则加\n        for (int i = 0; i < lm.length(); i++) {\n            char c = lm.charAt(i);\n            if (c == 'I') sum += 1;\n            if (c == 'V') sum += 5;\n            if (c == 'X') sum += 10;\n            if (c == 'L') sum += 50;\n            if (c == 'C') sum += 100;\n            if (c == 'D') sum += 500;\n            if (c == 'M') sum += 1000;\n        }\n        //indexOF(V)返回改子字符串的索引\n        if (lm.indexOf(\"IV\")>=0) sum -= 2;\n        if (lm.indexOf(\"IX\")>=0) sum -= 2;\n        if (lm.indexOf(\"XL\")>=0) sum -= 20;\n        if (lm.indexOf(\"CD\")>=0) sum -= 200;\n        if (lm.indexOf(\"CM\")>=0) sum -= 200;\n        if (lm.indexOf(\"XC\")>=0) sum -= 20;\n        System.out.println(sum);\n    }\n    //把他们放在键值对里（HashMap），挨个遍历\n    private static void method2(String lm) {\n        //给罗马数字赋值\n        Map<Character,Integer> map  = new HashMap<>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n\n            //把数字分成数组\n            //十进制的值\n            int sum = 0;\n            char[] chars = lm.toCharArray();\n            //循环字符数组，从右往左,\n            for (int i = chars.length-1; i >= 1; i--) {\n                //最好是改变i的初值，而不是改变索引\n                //当前的值\n                int cur = map.get(chars[i]);\n                //前一个的值\n                int left = map.get(chars[i - 1]);\n                //如果当前值大于左，则相减\n                //如果为第一次，则需要改变公式\n                if (i == chars.length-1){\n                    if (left < cur){\n                        sum = sum  + cur - left;\n                    }else {\n                        sum = sum +cur+ left;\n                    }\n                }else{\n                    if (left < cur){\n                        sum = sum  -  left;\n                    }else {\n                        sum = sum + left;\n                    }\n                }\n            }\n            System.out.println(sum);\n    }\n    //同法二思路一样的，但是做了算法简化\n    private static void method3(String lm) {\n        HashMap<String, Integer> map=new HashMap<String, Integer>();\n\n        map.put(\"I\", 1);\n        map.put(\"V\", 5);\n        map.put(\"X\", 10);\n        map.put(\"L\", 50);\n        map.put(\"C\", 100);\n        map.put(\"D\", 500);\n        map.put(\"M\", 1000);\n\n        int result=0;\n        for(int i=0;i<lm.length();i++){\n            //只算除最后一位的前面的数\n            if(i <= lm.length()-2){\n                //+\"\"的作用是变成字符串，因为我Map键为String类型\n                //如果左边小于右边，则减，并且i再加+1，跳到下两个，否则则每次只加一位\n                if(map.get(lm.charAt(i)+\"\") < map.get(lm.charAt(i+1)+\"\")){\n                    result += (map.get(lm.charAt(i+1)+\"\")-map.get(lm.charAt(i)+\"\"));\n                    i++;\n                }else{\n                    result += map.get(lm.charAt(i)+\"\");\n                }\n                //最后一位直接加\n            }else{\n                result += map.get(lm.charAt(i)+\"\");\n            }\n        }\n        System.out.println(result);\n    }\n}\n\n```\n","tags":["枚举"],"categories":["算法","枚举"]},{"title":"看不懂辗转相除法求最小公约数？以身相许那种哦！","url":"/2024/01/06/看不懂辗转相除法求最小公约数？以身相许那种哦！/","content":"给你打个比喻吧：你英雄救美了，美女想要报答你，你想要1000块感谢费，但是美女却想要以身相许😁，懂了吧，同样都是报答，只是用了不一样的方式，辗转相除法也是这样，你两个数的最大公约数不容易求，我就用另外两个简单的数来解决。\n<!--more-->\n![下载.jpg](http://ww1.sinaimg.cn/large/006ncldEgy1ghhjd9n5azj305004q745.jpg)\n\n废话不多说，看定理。\n### 定理：\n**辗转相除** 可以求最大公约数，顾名思义，反复的除，最终得到两数的最大公约数。\n首先我们来分析下定理：\n> 定理：**两个整数**的**最大公约数**等于其中**较小**的那个数**和**两数**相除余数**的**最大公约数**。最大公约数（Greatest Common Divisor）缩写为GCD。\ngcd(a,b) = gcd(b,a mod b) (不妨设a>b 且r=a mod b ,r不为0)\n\n\n\n文字不好理解，举个实例：\n134 / 18 = 7 ... **8**\n18 / **8** = 2 ... **2**\n8 / **2** = 4 ...  **0**\n\n看清了吧，是不是和定理一模一样，所以我们要找最大公约数，而134 /18的和8 / 2的最大公约数相等，所以我们只需要求出8 / 2的最大公约数，是不是就是开头说的换了两个数再求，而我们要知道，因为**两数相除，余数为0，其除数必定为最大公约数**，所以这里的2也就是我们要找的138 / 18 的最大公约数。至于证明，百度搜索，都有。主要证明思路就是，有a/b余r一式， 先假设y为a，b的公约数，再证明b,r的公约数也为y。\n\n### 思路：\n通过定理我们知道，要计算两数最大公约数，我们只需要一直递归就行了，直到余数为0，最大公约数就是**较小的那个数（除数）**。递归相信大家都了解过吧，必定有一出口，保证程序停止或返回，那么这里的出口条件就是上面例子的2，即**余数为0**。程序就是先找出输入参数谁打谁小，再判断余数是否为0（出口），再递归。代码用java写的，其实没啥差别，也没用api，思路都一样，格式不一样罢了。\n\n### 代码：\n所以我们开始写代码了：\n```java\nprivate static void method4(int m, int n, int ji) {\n        //相比较两个数，把较小的那个数赋值给smallNum;\n        int smallNum = (m > n ? n:m);\n        int bigNum = (m > n ? m:n);\n        if ( n < 0 || m < 0 ){\n            System.out.println(\"输入有错，结束了\");\n        }else{\n            //余数为0，smallNum就是那个最大公约数\n            if (bigNum % smallNum == 0){\n                System.out.println(\"最小公倍数\"+(ji / smallNum)+\"   最大公约数\"+smallNum);\n                //我写了几种方法，方便调用，所以返回的空\n                return;\n            }\n            method4(smallNum,bigNum % smallNum, ji);\n        }\n    }\n```\n通过定理我们知道较小数为除数吧，所以我们直接每次递归时，就把较小那个值找出来。然后把它变成除数，不就行了吗。\n\n什么你还没学递归，不要紧，我还有一种方法，就是**while循环**，while循环就不用判断谁大谁小了，因为小数%大数=小数本身，代码搞起来：\n```java\nprivate static void method2(int m ,int n,int ji) {\n        while(true){\n            if ((m = m % n) == 0){\n                System.out.println(\"最大公约数\"+n);\n                System.out.println(\"最小公倍数\"+(ji / n));\n                System.exit(0);\n            }\n            if ((n = n % m) == 0) {\n                System.out.println(\"最大公约数\"+m);\n                System.out.println(\"最小公倍数\"+(ji / m));\n                System.exit(0);\n            }\n        }\n    }\n```\n\n其实我还有一种枚举的算法，就不写了。当然求解最大公倍数，辗转相除还不是最优，还有更优，大家可以搜搜看。如果有时间，我在补充其他的算法。","tags":["枚举"],"categories":["算法","枚举"]},{"title":"模拟B,S服务器","url":"/2024/01/06/模拟B,S服务器/","content":"\n\n最近学到了网络编程，有个练习：\n**模拟B\\S服务器 模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。**\n**踩了两个坑**，就是：\n<!--more-->\n- ①HTTPS，不能用这个协议，来访问，因为这玩意是加密了的，一开始我还以为它传的不是UTF-8，因为我用的IDEA，默认UTF-8，我还用InputStreamReader去转换，但是发现没法，后来，突然想起了，HTTPS是加密的，然后用HTTP试了，就可以了。\n- ②网站输入的地址，可以用绝对路径，也可用相对路径，相对路径是<font color=red>相对于我们写的服务端类的项目位置</font>比如我的服务端： 我们的地址就要这样输入：\n- **http://localhost:8888/Advanced/src/Net/BSTCP/web/index.html**\n \n![(15)4L~J0~R(92LYVW27ZTY.png](http://ww1.sinaimg.cn/large/006ncldEgy1gh3ccc6b8nj30hn0fcmy2.jpg)\n\n\n**注意事项：**\n- ①这个是HTTP的响应头是固定的格式，需要注意：\n  Http响应头要固定：\n- ②谷歌看不了，建议换其他浏览器看。\n  ```java\n  // 写入HTTP协议响应头,固定写法\n    os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\n    os.write(\"Content‐Type:text/html\\r\\n\".getBytes());\n    // 必须要写入空行,否则浏览器不解析\n    os.write(\"\\r\\n\".getBytes());\n  ```\n\n\n **写代码思路**\n1. 客户端是网站，我们只写服务端\n2. 需要写两个服务端，一个是向客户端发送html代码，一个是发送图片\n3. 建立连接时，<font color=red>需要使用HTTP协议，而不能使用HTTPS协议</font>，这个协议被加密了，所以客户端只能输出加密的请求头。\n4. 服务端的执行步骤：\n\t1. 先创建ServerSocket，监听请求，接收到了，就使用accept( )捕获。\n\t2. 利用网络输入流，读取客户端请求头，然后获取Get请求，其中的文件地址。\n\t3. 处理地址格式\n\t4. 使用本地文件流，读取文件，并向客户端输出\n\t5. 在创建一个传输照片的服务端，与传输html的服务端代码几乎一样，差别在于，传输照片服务端，<font color=red>要一直监听请求，因为他传输的不是一张照片</font>\n\t6. 优化：\n      \t  <font color=red>使用多线程，加快传输效率</font>\n\n\n下面放出全部代码：\n**html服务端：**\n```java\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n//http://localhost:8888/Advanced/src/Net/BSTCP/web/index.html HTTP/1.1\n//不能使用https，加密协议\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"服务端启动，等待连接。。。。\");\n        //创建一个服务器ServerSocket,和系统要指定的端口号\n        ServerSocket server = new ServerSocket(8888);\n        //使用accept方法获取到请求的客户端对象(浏览器)\n        Socket socket = server.accept();\n        //使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象\n        InputStream is = socket.getInputStream();\n\n        //输出客户端的请求\n        /*byte[] bytes = new byte[1024];\n        int len = is.read(bytes);\n        System.out.println(new String(bytes,0,len));\n        System.out.println(\"cao\");*/\n\n        //把is字节流，转换成字符流，并且使用缓冲流读取\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n\n        //读取第一行GET请求的内容\n        String s = br.readLine();\n        //按空格把它分开\n        String[] s1 = s.split(\" \");\n        //把前面的\"/\"给排除，使用字符串的截取\n        String path = s1[1].substring(1);\n        System.out.println(path);\n\n        //创建一个fis流，读取本地的index.html文件\n        FileInputStream fis = new FileInputStream(path);\n        //获取网络输出流OutputStream，向客户端输出页面\n        OutputStream os = socket.getOutputStream();\n\n        // 写入HTTP协议响应头,固定写法\n        os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\n        os.write(\"Content‐Type:text/html\\r\\n\".getBytes());\n        // 必须要写入空行,否则浏览器不解析\n        os.write(\"\\r\\n\".getBytes());\n\n        //向客户端输出\n        byte bytes[] = new byte[1024];\n        int len = 0;\n        while((len = fis.read(bytes))!=-1){\n            os.write(bytes);\n        }\n        //关闭资源\n        fis.close();\n        br.close();\n        socket.close();\n\n    }\n}\n\n```\n\n\n**照片服务端**\n```java\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class ImageServer {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"服务端启动，等待连接。。。。\");\n        //创建一个服务器ServerSocket,和系统要指定的端口号\n        ServerSocket server = new ServerSocket(8888);\n        while (true){\n            //使用accept方法获取到请求的客户端对象(浏览器)\n            Socket socket = server.accept();\n            //使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象\n            InputStream is = socket.getInputStream();\n\n            //输出客户端的请求\n            /*byte[] bytes = new byte[1024];\n            int len = is.read(bytes);\n            System.out.println(new String(bytes,0,len));\n            System.out.println(\"cao\");*/\n\n            //多线程，加快传输速度\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try{\n                        //把is字节流，转换成字符流，并且使用缓冲流读取\n                        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n\n                        //读取第一行GET请求的内容\n                        String s = br.readLine();\n                        //按空格把它分开\n                        String[] s1 = s.split(\" \");\n                        //把前面的\"/\"给排除，使用字符串的截取\n                        String path = s1[1].substring(1);\n                        System.out.println(path);\n\n                        //创建一个fis流，读取本地的index.html文件\n                        FileInputStream fis = new FileInputStream(path);\n                        //获取网络输出流OutputStream，向客户端输出页面\n                        OutputStream os = socket.getOutputStream();\n\n                        // 写入HTTP协议响应头,固定写法\n                        os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\n                        os.write(\"Content‐Type:text/html\\r\\n\".getBytes());\n                        // 必须要写入空行,否则浏览器不解析\n                        os.write(\"\\r\\n\".getBytes());\n\n                        //向客户端输出\n                        byte bytes[] = new byte[1024];\n                        int len = 0;\n                        while((len = fis.read(bytes))!=-1){\n                            os.write(bytes);\n                        }\n                        //关闭资源\n                        fis.close();\n                        br.close();\n                        socket.close();\n                    }catch (IOException e){\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n\n\n        }\n\n    }\n}\n\n```","tags":["TCP"],"categories":["Java"]},{"title":"求n个最小公倍数","url":"/2024/01/06/求n个最小公倍数/","content":"## 题目\n如果两个数很大，怎样求最大公约数，最小公倍数？\n如果是n个数呢？比如1000个数的最小公倍数<!--more-->\n> 输入\n> 2 4 6\n>  3 2 5 7\n\n> 输出\n> 12\n> 70\n## 思路\n首先最大公约数可以用辗转相除法，定义为lcm(m,n)，然后再定义一个方法gcd(m,n)求最大公约数，用公式法 ：最小公倍数 = m * n / lcm(m,n),使用一个数组nums来装输入的数据，大小n由输入决定`int nums[] = new int[n];`,然后在使用一个while循环，来输入装进数组nums的数据。最后定义一个int a，储存gcd(m,n)参数中的m。\n\n不知道辗转相除法，可以看我的[这篇博客](https://blog.csdn.net/weixin_46509714/article/details/107855377)，详细介绍了的，很简单。\n\n## 代码\n\n```java\npublic class Test4 {\n    public static void main(String[] args) {\n        int i = 0,m;\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();//输入要输的个数\n        int nums[] = new int[n];\n        while (n != 0 ){\n            m = sc.nextInt();\n            if (m == 0){\n\n            }else{\n                nums[i] = m;\n                i++;\n            }\n            n--;\n        }\n        int a =nums[0];//lcm的第一个参数\n//        System.out.println(Arrays.toString(nums));\n        for (int j = 1 ; j < nums.length; j++){\n            a =  gcd(a,nums[j]);\n        }\n        System.out.println(\"他们的最小公倍数=\"+a);\n    }\n    //求最大公因数\n    public static int lcm(int m,int n ){\n        int left = (m > n)? m : n; //左边是较大的数\n        int right = (m > n)? n : m; //右边是较小的数\n        if ((left % right) == 0){\n            return  right;\n        }\n        return lcm(right , left % right);\n    }\n    //求最小公倍数\n    public static int gcd(int m,int n){\n        return m * n /lcm(m , n);\n    }\n\n}\n\n\n```","tags":["算法"],"categories":["算法","递归"]},{"title":"扩展欧几里得","url":"/2024/01/06/扩展欧几里得/","content":"扩展欧几里得定理\n扩展欧几里得定理（Extended Euclidean algorithm, EXGCD），常用于求ax+by=gcd(a,b)  的一组可行解。\n<!--more-->\n![QQ截图20200906101843.png](http://ww1.sinaimg.cn/large/006ncldEgy1gigpsq3ql1j30mt0ejt9w.jpg)\n\n将  不断代入递归求解直至  （最大公约数，下同）为 0 递归 x=1,y=0 回去求解。\n\n```\npublic static int f(int a,int b,int[] xy){\n        if(b == 0){\n            xy[0] = 1;\n            xy[1] = 0;\n            return a;\n        }\n        int gcd = f(b,a%b,xy);\n        int t = xy[0];  //t = x2;\n        xy[0] = xy[1];  //x1 = y2;\n        xy[1] = t - a/b*xy[1];  //y1 = x2 - a/b*y2\n        return gcd;\n    }\n\n```\n\n这里要传一个数组，因为，最后要获取被改变的x，y的值。c语言用指针也可以，传地址。\n\n函数参数的传递的是值，swap(int a,int b)中，a和b都只是得到了实参的值而已，然后就跟实参没有任何关系了。\n\n如果用swap(int* a,int* b)，依然是得到实参的值，但由于a,b是指针，得到的将是地址，那么参数和实参所指的地址是一样的，如果在函数体里交换地址所指的存储内的东西，那么就是真的交换了。","tags":["扩展欧几里得"],"categories":["算法"]},{"title":"指针到底是个什么鬼,怎么用","url":"/2024/01/06/指针到底是个什么鬼,怎么用/","content":"学数据结构时，创建链表，他定义了个二级指针，很懵逼，所以就有了这篇博客。指针的 * 有啥用?    <!--more-->\n在我看来就像打排位匹配对手一样，什么样的段位匹配什么样的对手。就比如我是黑铁4，就匹配不到最强王者。\n\n### 了解你定义的变量，是怎么来的:\n首先我们来看基本数据类型，`int a = 100`, a在内存中，是怎么保存的呢，首先开辟一个内存，地址如：0X61，然后他代表的值是100。\n\n然后再来看 一级指针变量 `int *p1 = &a`,我们首先还是需要去内存中开辟一个空间，然后假如 p1这个指针的值是 0X62 ，然后注意了，我们也给p1这个指针，赋值了的，所以他就指向 a 的地址: 0X61。\n\n最后就是二级指针变量了， `int **p2 = &p1`， 如上，**p2的地址值为 0X63，他指向的值就应该是 p1的地址值 。\n\n如下图:\n\n![二级指针.png](http://ww1.sinaimg.cn/large/006ncldEgy1ghsq8pni44j31010b9wee.jpg)\n\n### 总结一下：\n这时候你应该悟了，其实每个变量(无论是指针变量还是基本数据类型)都应该有两个值,一个是自己的地址值，一个是装(储存)的值，只不过基本类型和指针装的不一样，一个装数据，一个装地址。\n\n对于int a来说，他的地址是0X61，他装的是100，而对于一级指针int *p1来说，他的地址是0X62，而他装的是 a的地址0X61，对于int **p2来说，他的地址是0X63，而他装的是 *p1的地址 0X62;\n\n### 柯南时间到:\n现在就来揭秘，指针前面那个 * 有啥用(我们要知道这玩意有啥用，最有利的证据，就是用代码输出结果)：\n```C\n#include <stdio.h>\nint main(){\n    int a =100;\n    int *p1 = &a;\n    int **p2 = &p1;\n    int ***p3 = &p2;\n    printf(\"%d, %d, %d, %d\\n\", a, *p1, **p2, ***p3);\n    printf(\"&p2 = %#X, p3 = %#X\\n\", &p2, p3);\n    printf(\"&p1 = %#X, p2 = %#X, *p3 = %#X\\n\", &p1, p2, *p3);\n    printf(\" &a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\\n\", &a, p1, *p2, **p3);\n    return 0;\n}\n```\n运行结果：\n```c\n100, 100, 100, 100\n&p2 = 0X28FF3C, p3 = 0X28FF3C\n&p1 = 0X28FF40, p2 = 0X28FF40, *p3 = 0X28FF40\n&a = 0X28FF44, p1 = 0X28FF44, *p2 = 0X28FF44, **p3 = 0X28FF44\n```\n\n我们从结果，再结合书上讲的，就精炼一下嘛，`&`表示取**取变量的地址符号**，`*`则表示**取值符号**,。\n\n1. 想要获取**指针指向的数据**时，一级指针加一个`*`，二级指针加`两个*`，三级指针加`三个*`,以次类推。\n2. 而如果指针少一个`*`，就表示,指针指向数据的地址值。\n3. 而指针不加 `*`，就表示自己储存的什么值(你看a是不是就为100，100就是他储存的值嘛)。\n\n结合这个图来看:\n![二级指针.png](http://ww1.sinaimg.cn/large/006ncldEgy1ghsrvdxoqcj31010b9wee.jpg)\n\n我二级指针，有两个`*`，就直接可以指到a装的数据了，而少了一个*就代表指向a的地址值(即指向的p1储存的值)。那再少一个就只能指到自己了嘛,那不就是自己储存的p1的地址值吗。\n\n由此我们可以发现，指针的`*`就像一个打排位，什么样的段位匹配什么样的段位，几个`*`就指向那个值。\n\n推荐阅读:http://c.biancheng.net/view/2016.html","tags":["指针","C语言"],"categories":["C语言"]},{"title":"力扣——第N个泰波那契数列的值","url":"/2024/01/06/力扣——第N个泰波那契数列的值/","content":"\n# 力扣1137——第N个泰波那契数列的值\n\n\n<!--more-->\n## 题目：\n\n> 泰波那契序列 Tn 定义如下： \n    T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2\n    给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n    示例 1：\n    输入：n = 4\n    输出：4\n    解释：\n    T_3 = 0 + 1 + 1 = 2\n    T_4 = 1 + 1 + 2 = 4\n    示例 2：\n    输入：n = 25\n    输出：1389537\n    提示：\n    0 <= n <= 37\n    答案保证是一个 32 位整数，即 answer <= 2^31 - 1。\n\n## 思路及代码：\n有题目的本意就知道了，这是一个递归，所以最简单的办法就是递归四步走，确定参数，定义函数作用，递归出口，等价条件。但是通过这种方法，会造成大量的重复计算，可以画个树，他的杂度是以3^n。\n\n所以我们可以使用动态规划：\n\n法一：**动态规划+递归**：找个数组来装第N个泰波那契数列的值，每次递归就判断，是否数组中是否有这个值。\n```java\npublic static int f2(int n){\n        int result = 0;\n        if (dp[n] != 0) return dp[n];\n        if (n == 0) return 0;\n        if (n == 1 || n == 2) return 1;\n        //把当前的值放进dp中，进行记录，下次遇到了要算这个f(n)就拿出来用\n        result = f2(n-1) + f2(n-2)+ f2(n-3);\n        dp[n] = result;\n        return result;\n    }\n```\n法二：**动态规划非递归**，三个数一直保存，当前计算的n的前三项的值。\n```java\npublic static int f3(int n){\n        if (n < 3) return n == 0 ? 0:1;\n        //定义三个变量，装临时值\n        int a=0 ,b=1, c=1;\n        for (int i = 3; i <= n; i++){\n            int temp = a + b + c;\n            a = b;\n            b = c;\n            c = temp;\n        }\n        //c就是最终的结果\n        return c;\n    }\n```\n法三：**动态规划，自底向上**\n```java\npublic static int f4(int n){\n        int dp[] = new int[n+3];\n        dp[1] = 1;\n        dp[2] = 1;\n        for (int i = 3; i <= n; i++){\n            dp[i] = dp[i-1] + dp[i-2]+ dp[i-3];\n        }\n        return dp[n];\n    }\n```\n","tags":["力扣","递归","动态规划","时间复杂度"],"categories":["算法"]},{"title":"回顾迷茫的大一大二","url":"/2024/01/06/回顾迷茫的大一大二/","content":"\n“下学期我一定好好学习”，到了大二上，这是我第三次对室友说了，不知道这句flag是不是全国统一。反正对我来说，这的确是一句flag。\n<!--more-->\n从压抑的高中到自由的大学，这无疑是天堂。不知道有多少个高中夜里，我曾想象着：大学美好的校园爱情，想象着校园活动多么多姿多彩，想象着老师多么有趣，反正觉得大学的空气都是甜的。初到学校，这的确挺美好的，除了有点旧。。。\n\n学校通知我们写一封“写给四年后的自己”的信，虽然已经记不到自己写的什么了，但是肯定很美好吧。\n\n我喜欢唱歌，经过一轮面试，成功成为了一名队员。心想：肯定会遇见很多很美好的人或事吧，充满期待。和室友打成一片后，注册了差不多一样的名字的号，开始了五黑之旅，胜率55开吧，但也还不错。由于我是软工专业的，大一学习C语言，那叫一个“天书”，逐渐养成了上课玩手机的习惯，开始，还不觉得什么，到了讲指针，就没听过了，哈哈哈。真的就是天书吗？我可是打引号了的。大一上最高兴的一次，大概是和室友出去吃自助餐，那天下着小雨，我们几个人，撑到炸裂，还顺走了餐馆几瓶饮料，回学校的路上，下着小雨，挺诗意的。后来还和室友去了一些景点。时间来到了期末考试，我开始泡图书馆，学习着“天书”，看着空白的教材，这就是0的突破嘛，哈哈。不过还好，凭借着临时抱佛脚，还真没挂科，居然还考了专业二十来名。就离谱。\n\n夏天是最美的季节，不如说是人更美。爱情向来都是要主动地，学校里这么多女生，都还没交女朋友，实在说不过去，我心想道。那天，下课的时候，一个女生正和同桌闲聊。惊鸿一瞥，淦！这妹子真tm好看。于是凭借着强大的皮肤厚度，要到了这个女生的联系方式。第一次约会，我定在了电影院，电影名字叫《何以为家》讲的是一个小孩带着妹妹流浪展的开一系列的事。很戏剧性的，我把票买错了，电影都开始了。哭笑不得，所以我俩就去逛商城，她是学语文的，通过聊天感觉这个女生真的好温柔。在发起猛烈攻势后，过了一段时间后，终于还是抱得美人归。大一下结。\n\n大二上我依然对室友说着熟悉的flag，“这学期我一定好好学习”。好家伙，云顶之弈，悄然上线，本来已经弃坑的LOL，又响起了熟悉的bgm，沉迷云顶。女朋友话贼多，自从我经常打游戏，就很少和女朋友交流。后来才知道她为啥不给我发消息，只要一看见我是电脑在线，就不理我了，哈哈哈。感情需要两个人维护，最后还是分手了。大二上学java时，是一个魔鬼老师在讲课，只有靠提前预习才能听懂，从来不预习的我，撑到到了毛概课，上毛概不玩手机，就看java，终于java还是考了八十多分，大学的考试，我觉得真的是很简单，不会考高深的，只考基础，所以这分数也就没含金量。\n\n时间到了寒假，很不幸的爆发了疫情。在家学习的我，依然对自己说“这学期我一定好好学习”，这句flag，终于没打我脸了，我跟着网课学习，确实学到了不少东西。是环境造成的？在学校大家都打游戏，你不玩就显得格格不入，其实问自己心理，难道自己不想玩？终究问题还是在自己身上。就这样大一大二宣告破产。\n\n“生活就像一块巧克力，你永远不知道下一块是什么味道”既然都是自己选择的巧克力，作为成年人，就要接受，控制权在自己手上。只有自己才能把握自己的未来，生活本就由自己书写，由自己选择。回顾我的大一大二，有甜，有苦的巧克力，但是青春要是没一点迷茫，一直按部就班也太没意思了。既然过去已经过去，也只能当做回忆，那最重要的就是现在。确定好自己的目标，就去冲，年轻人，要是没一点血性，还叫年轻人？希望两年之后呢，我也选择到了那块的甜味巧克力。\n\n\n\n","categories":["杂记"]},{"title":"力扣——划分为k个相等的子集","url":"/2024/01/06/力扣——划分为k个相等的子集/","content":"## 一、题目：\n>   给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。\n    示例 1：\n    输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 \n    输出： True\n    说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。\n    提示：\n    1 <= k <= len(nums) <= 16\n    0 < nums[i] < 10000\n<!--more-->\n\n## 二、思路：\n首先是题意：做每道算法题，最重要的是，读懂题意，从分析我们可以得出来的是，目标值及每个子集的和target=sum(nums)/k,所以就确定了目标值target。\n得出目标值后，我们可以得到一些一定为false的情况，如\n1. 目标值不为整数\n2. nums中有值大于target的\n   \n我们还可以先找出nums中是否有等于target的值，\n这道题的思路就是把**nums所有元素都放进长度为k的groups数组**当中，如果刚刚放完，则返回true。\n对于放进groups这个动作我们称它为搜索元素放进group，对于一共k个子集的我们只需要一个for循环就能解决。\n使用递归我们可以做到一直搜索。只用改变当前搜索的值，就能一直向group数组中添加。\n如果看不懂思路，请结合代码分析。\n\n## 三、代码：\n\n```java\npublic class 划分为k个相等的子集 {\n    public static void main(String[] args) {\n        划分为k个相等的子集 a = new 划分为k个相等的子集();\n        int[] nums = {4, 3, 2, 3, 5, 2, 1};\n        System.out.println(a.canPartitionKSubsets(nums,4));\n    }\n\n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        int sum = Arrays.stream(nums).sum();\n        if (sum % k > 0) return false;\n        //由题意我们可以知道目标值绝对是sum/k\n        int target = sum / k;\n        //给nums数组排序，递增顺序\n        Arrays.sort(nums);\n        int row = nums.length - 1;\n        //如果最大的值大于目标值，则改数组肯定不满足条件，直接返回false\n        if (nums[row] > target) return false;\n        //如果有等于目标值的，k--，row--\n        while (row >= 0 && nums[row] == target) {\n            row--;\n            k--;\n        }\n        return search(new int[k], row, nums, target);\n    }\n\n\n    //函数作用：搜索nums中的每一个数，能不能添加到groups里，并且和等于target，row代表当前添加到groups中的数\n    public boolean search(int[] groups, int row, int[] nums, int target) {\n        //如果nums中没有数了，则代表所有数全部放入groups中\n        if (row < 0) return true;\n        //注意row--，先赋值，再--\n        int v = nums[row--];\n        //遍历groups的k个子集\n        for (int i = 0; i < groups.length; i++) {\n            if (groups[i] + v <= target) {\n                groups[i] += v;\n                if (search(groups, row, nums, target)) return true;\n                //不能添加到groups中，则把它减去，及回溯\n                groups[i] -= v;\n            }\n            //如果遍历完了，所有数都不能放进groups中，及没有值相加或者本身等于target，则跳出循环break,或者return false;\n            if (groups[i] == 0) return false;\n        }\n        return false;\n    }\n}\n\n\n```","tags":["算法","力扣"],"categories":["算法","递归"]},{"title":"力扣——最长同值路径","url":"/2024/01/06/力扣——最长同值路径/","content":"## 一、题目：\n\n \n    \n>   给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。\n    注意：两个节点之间的路径长度由它们之间的边数表示。   <!--more-->\n    示例 1:\n    输入:\n                5\n                / \\\\\n                4   5\n            / \\\\   \\\\\n            1   1   5\n    输出:\n    2  \n    示例 2:\n    输入:\n                1\n                / \\\\\n                4   5\n            / \\\\   \\\\\n            4   4   5\n    输出:\n    2\n    注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。\n\n\n## 二、思路：\n这道题的题意就是找出二叉树，最长同值路径。\n分为两种情况\n（1）从根节点出发，左子树的最长同值路径\n（2）从根节点出发，右子数的最长同值路径\n而有一种特殊的是，根节点在中间，就比如实例2的同值4，这种，只需要再我们遍历二叉树的时候，去判断，是否 **左右子节点与根节点相等就行了**，那么与就需要最长路径就需要+2，（1）（2）就只需要+1。\n对于二叉树这种数据结构，很明显的使用递归去遍历左右子树就行了。\n\n## 三、代码：\n```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n        val = x;\n    }\n}\npublic class 最长同值路径 {\n    static int ans;\n\n    public static void main(String[] args) {\n        //第一层\n        TreeNode node = new TreeNode(1);\n        //第二层\n        node.left = new TreeNode(4);\n        node.right = new TreeNode(4);\n        //第三层\n        node.left.left = new TreeNode(4);\n        node.left.right = new TreeNode(4);\n        node.right.right = new TreeNode(5);\n\n        System.out.println(longestUnivaluePath(node));\n    }\n\n    public static int longestUnivaluePath(TreeNode root) {\n        ans = 0;\n        longestPath(root);\n        return ans;\n\n    }\n    //递归函数功能：搜寻以node为起点的最长同值路径:要么是以node为起点的左子树，要么是以node为起点的右子树\n    public static int longestPath(TreeNode node) {\n        if (node == null) return 0;\n        int maxLorRres = 0;\n        int left = longestPath(node.left); //node左子树的最长同值路径\n        int right = longestPath(node.right);//node右子树的最长同值路径\n        //这种情况对于寻找最长同值路径长有帮助，对于搜索以root为路径起始点的最长路径没有帮助\n        if (node.left != null && node.left.val == node.val && node.right != null && node.right.val == node.val) {\n            ans = Math.max(ans, left + right + 2);\n        }\n        //从左右子树中选择最长的同值路径\n        if (node.left != null && node.left.val == node.val) {\n            maxLorRres = left + 1;\n        }\n        if (node.right != null && node.right.val == node.val) {\n            maxLorRres = Math.max(maxLorRres, right + 1);\n        }\n        //从ans与maxLorRres中更新最大值\n        ans = Math.max(ans, maxLorRres);\n        //返回节点的左右最大的同值的值\n        return maxLorRres;\n    }\n\n\n}\n```","tags":["算法","力扣"],"categories":["算法","递归"]},{"title":"力扣——二叉搜索树的范围和","url":"/2024/01/06/力扣——二叉搜索树的范围和/","content":"## 题目：\n\n> 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。\n    二叉搜索树保证具有唯一的值。\n    示例 1：\n    输入：root = [10,5,15,3,7,null,18], L = 7, R = 15\n    输出：32\n    示例 2：\n    输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10\n    输出：23\n    提示：\n    树中的结点数量最多为 10000 个。\n    最终的答案保证小于 2^31。\n<!--more-->\n\n## 思路：\n首先是题意：这道题的意思就是，找出在给定左右节点范围中的节点数的和。\n\n所以我们可以遍历所有节点，于是我们可以使用递归。\n\n法一，使用递归但是方法作用与法二不同，作用写在了代码的第一句，法三就是用while循环，遍历每个节点\n\n\n## 代码：\n\nmain函数：\n```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n        val = x;\n    }\n}\n\n\n//递归实现深度优先搜索\npublic class 二叉搜索树的范围和 {\n    static int result;\n    static int ans;\n    public static void main(String[] args) {\n        result = 0;\n        //第一层\n        TreeNode node = new TreeNode(10);\n        //第二层\n        node.left = new TreeNode(5);\n        node.right = new TreeNode(15);\n        //第三层\n        node.left.left = new TreeNode(3);\n        node.left.right = new TreeNode(7);\n        node.right.right = new TreeNode(18);\n        //法一，递归但是方法作用与法二不同，递归实现深度优先遍历：\n//        dfs(node,7, 15);\n//        System.out.println(result);\n        //法二：\n//        System.out.println(dfs2(node,7,15));\n        //法三,迭代实现深度优先遍历:\n        f3(node,7,15);\n        System.out.println(ans);\n\n    }\n\n```\n\n\n法一：\n```java\n//当前节点是否能进入result的和,遍历了所有节点\n    public static void dfs(TreeNode node, int l, int r) {\n        if (node != null){\n            if (l <= node.val && node.val <= r) {\n                result += node.val;\n            }\n            //这里必须要遍历每个节点，所以需要node.val > l ,dfs(node.left,l,r)\n            if (node.val > l) dfs(node.left,l,r);\n            if (node.val < r) dfs(node.right,l,r);\n        }\n    }\n\n```\n\n\n法二：\n```java\n//该树的满足范围的和,，没有遍历所有节点\n    //如果当前节点的值小于left，和等于右子数之和\n    //如果当前节点的值大于right，和等于左子数之和\n    //如果当前节点的值在范围里，和等于右子数+左子树之和+当前节点的值\n    private static int dfs2(TreeNode node, int l, int r) {\n        if (node == null) {\n            return 0;\n        }\n        if (node.val < l){\n            return dfs2(node.right,l,r);\n        }\n        if (node.val > r){\n            return dfs2(node.left,l,r);\n        }\n        return dfs2(node.left,l,r)+dfs2(node.right,l,r)+node.val;\n    }\n\n```\n\n\n法三：\n```java\n\n//迭代实现深度优先遍历，遍历了所有节点\n    public static int f3(TreeNode root,int L, int R){\n        ans = 0;\n        Stack<TreeNode> stack = new Stack();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            if (node != null) {\n                if (L <= node.val && node.val <= R)\n                    ans += node.val;\n                if (L < node.val)\n                    stack.push(node.left);\n                if (node.val < R)\n                    stack.push(node.right);\n            }\n        }\n        return ans;\n    }\n```","tags":["算法","力扣"],"categories":["算法","递归"]},{"title":"全排列算法及解决数字搭积木问题","url":"/2024/01/06/全排列算法及解决数字搭积木问题/","content":"如果你是做这道题不会，那么你可以看这道题的解题思路，如果你是不太理解全排列算法，那么你可以通过这个题来理解。\n<!--more-->\n# 题目描述：\n小明最近喜欢搭数字积木。一共有10块积木，每个积木上有一个数字，0~9。\n\n搭积木规则：\n每个积木放到其它**两个积木的上面**，并且一定**比下面的两个积木数字小**。\n最后搭成4层的金字塔形，必须用完所有的积木。\n\n下面是两种合格的搭法：\n\n![QQ截图20200810184553.png](http://ww1.sinaimg.cn/large/006ncldEgy1ghlwrown88j304n07g0so.jpg)\n\n请你计算这样的搭法一共有多少种？\n\n# 分析\n一共有10个数字，要我们把所有可行的排列方式都求出来，一时没什么思路，索性就全排列了，把所有排列的情况都求出来，然后在把每种情况都判断一下，是不是就可以得到答案了。\n\n所以**全排列**怎么写成了第一大问题了。\n\n# 全排列\n\n对于这个问题来说，我们把金字塔当成一个int数组，那么就为 全排列这个数组{0,1,2,3,4,5,6,7,8,9}。\n\n太长了，想不明白呀，所以来看比较少的呗。\n对于{0,1}全排列，就是把0抽出来，1做全排列，再把1抽出来，0做全排列，对于{0,1,2},就是：\n1. 把0抽出来，把1,2做全排列，\n2. 把1抽出来，把0，2做全排列，\n3. 把2抽出来，把0，1做全排列。\n4. 接下来那不就和上面那个{0,1}一样了吗?\n   \n这是不是个递归呢?很明显吧。的确是。\n\n那好我们定义一个方法，这个方法的作用是，**把list数组全排列**，而参数curr表示**当前抽出来的那个数**，就像上面例子提到的0一样。\n\n提出来了之后呢，是不是要把**curr交换**了，这样就可以把所有在这个位置上的所有情况列出来了，所以使用一个for循环，来交换curr和后面剩余数组的数(就是上面例子的1，2，3步骤)。\n\n所以紧接着定义一个方法，交换两数`swap(list,curr,j);`，当然你也可以把这个方法直接写到这个函数里面，但是毕竟不美观，不实用。\n\n重点来了：**回溯！！！**\n\n从这张图中，所谓回溯就是要回到上一没有操作过的状态，再去考虑别的情况。就下面这个A,B,C他需要回到上一次抽数出来之前的状态。这样他才能去抽另外一个数，全排列下一种情况。所以我们再写一遍`swap(list,curr,j);`，把它原来的状态恢复就行了嘛。\n\n![20180619204217111 (1).png](http://ww1.sinaimg.cn/large/006ncldEgy1ghlyriu8fyj30zs0ekmyh.jpg)\n\n\n问题分析到这了，我们的代码基本上就可以出来了，所以看下代码，如果看不懂在回到我的分析，相信你一定能看懂。\n\n\n\n```java\npublic class Test2 {\n    static int sum ;\n    public static void main(String[] args) {\n        int list[] = {0,1,2,3,4,5,6,7,8,9};\n        allSort(list,0);\n        System.out.println(sum);\n    }\n    //代表将第a[m]和a[n]相交换\n    public static void swap(int a[],int m ,int n){\n        int temp = a[m];\n        a[m] = a[n];\n        a[n] = temp;\n    }\n    //调用全排列数组list,curr代表当前放在第一个的为第几个数字，比如开始就为数组第0个数字\n    public static void allSort(int list[],int curr ){\n        //如果当前数组的索引等于数组的长了，就将方法加1\n        if (curr == list.length-1){\n            check(list);\n        }else {\n            for (int j = curr; j < list.length; j++){\n                swap(list,curr,j);//交换当前抽出来那个数\n                allSort(list,curr+1);\n                swap(list,curr,j);//回溯\n            }\n        }\n    }\n    public static void check(int list[]){\n        if (list[1] < list[0]) return;\n        if (list[2] < list[0]) return;\n        if (list[3] < list[1]) return;\n        if (list[4] < list[1]) return;\n        if (list[4] < list[2]) return;\n        if (list[5] < list[2]) return;\n        if (list[6] < list[3]) return;\n        if (list[7] < list[3]) return;\n        if (list[7] < list[4]) return;\n        if (list[8] < list[4]) return;\n        if (list[8] < list[5]) return;\n        if (list[9] < list[5]) return;\n        sum++;\n\n    }\n\n}\n\n```\n\n其实这个全排列都可以当成一个模板了，但是还是推荐大家一定要手敲，自己写代码，写出来了，才是自己的东西。\n\n图片参考：https://blog.csdn.net/Strom72/article/details/80738818\n\n","tags":["递归","全排列"],"categories":["算法","递归"]},{"title":"使用Luhn算法实现信用卡号验证","url":"/2024/01/06/使用Luhn算法实现信用卡号验证/","content":"## 问题描述：\n2：信用卡号的验证 【信用卡号的验证】 当你输入信用卡号码的时候，有没有担心输错了而造成损失呢？其实可以不必这么 担心，因为并不是一个随便的信用卡号码都是合法的，它必须通过 Luhn 算法来验 证通过。<!--more--> 该校验的过程： 1、从卡号最后一位数字开始，逆向将**奇数位**(1、3、5 等等)**相加。**\n2、从卡号最后一位数字开始，逆向将**偶数位**数字，**先乘以 2（如果乘积为两位 数，则将其减去 9），再求和。**\n3、将奇数位总和加上偶数位总和，结果应该可以被 10 整除。\n例如，卡号是：5432123456788881\n则，奇数位和=35 \n偶数位乘以 2（有些要减去 9）的结果：1 6 2 6 1 5 7 7，求和=35。 \n最后 35+35=70 可以被 10 整除，认定校验通过。\n请编写一个程序，从键盘输入卡号，然后判断是否校验通过。通过显示：“成功”， 否则显示“失败”。 比如，用户输入：356827027232780 程序输出：成功 \n【参考测试用例】\n 356406010024817 成功\n 358973017867744 成功\n 356827027232781 失败\n 306406010024817 失败\n 358973017867754 失败\n\n## 思路：\n没什么好说的，暴力破解就完事了，因为这个思路很简单，只需要一层for循环，因为要倒叙遍历，奇数位为i，偶数位就为i-1，然后在相加就好了。\n\n## 代码实现：\n```java\npublic class Test5 {\n    public static void main(String[] args) {\n        method(\"356827027232780\");\n    }\n\n    private static void method(String s) {\n        System.out.println(s.length());\n        char[] chars = s.toCharArray();\n        int odd =0;\n        int even =0;\n        for (int i = chars.length-1; i >= 0; ){\n            //把字符转化成int，先调用抽象方法，放回String，在把String转换为int，或者是强转，但是字符只能为1位\n            odd += Integer.parseInt(String.valueOf(chars[i]));\n            //如果大于10\n            //当前偶数\n            //如果当前为最后一位,偶数啥事不干\n            if (i == 0){\n\n            }else{\n                int currEven = Integer.parseInt(String.valueOf(chars[i-1]));\n                //如果当前偶数的两倍>=10\n                if (currEven*2 >= 10){\n                    even += currEven*2-9;\n                }else{\n                    even += currEven*2;\n                }\n            }\n            i -= 2;\n        }\n        if ((even+odd)%10==0){\n            System.out.println(\"卡号正确\");\n        }else{\n            System.out.println(\"卡号错误\");\n        }\n\n    }\n}\n\n```","tags":["枚举"],"categories":["算法","枚举"]},{"title":"使用SSM+spingboot+vue+shiro实现权限登录和增删查改","url":"/2024/01/06/使用SSM+spingboot+vue+shiro实现权限登录和增删查改/","content":"\n之前写了一篇博客是用，ssm+thymeleaf+vue+shiro完成一个具有**权限登录，且能增删查改**的这么一个项目。当时只记录了登录权限的操作，现在补充一下**增删查改**的具体实现。\n<!--more-->\n[上一篇博客：使用shiro实现登录权限认证](https://blog.csdn.net/weixin_46509714/article/details/109847283)\n详细代码说明。\n\n首先给出完整代码，[点击github连接自取](https://github.com/chenQD123/SSM/tree/master)。\n\n# 一、项目需求：\n1. 系统需要在spring boot下面开发 \n2. 数据库可以需要使用mybatis（可以混合jpa开发） \n3. 页面用Thymeleaf模板和Vue.js（vuejs组件可以用element UI） \n4. 登录权限采用spring boot security 或者shiro框架（任选其一） \n5. 工作量不能低于Boot管理系统，界面美观实用 \n   \n![ss](https://gitee.com/chenqd/pic/raw/master/20201130173347.png)\n\n\n# 二、使用到的技术栈：\n1. 数据库：springBoot，springMvc，mybatis\n2. 页面：thymeleaf，semantic,vue，bootstrap，axios\n3. 登录权限和认证：shiro\n\n\n# 三、开发过程：\n## 1. 大致开发流程：\n   * 登录：身份认证，权限授权\n   * 用户信息：增删查改\n\n## 2. 具体：\n###   2.1使用shiro安全框架：\n####  (1)首先编写我们的底层数据库sql语句和持久层entity类：\n\n我们需要三张表，User，Role，Permission，定义他们对于登录的作用，首先是通过姓名和密码查询User表是否有这个人，查询结束通过User的外键Role_Id，来映射这个人的角色，然后又通过Role表中的Id，来查询此角色对应的Permission表中的权限。这样我们就将这个人的身份与权限一并操作完，并且跳转到主页index.html，主页会根据权限，来展示对应的可操作事件，例如： **USER有查询的权限，ADMIN在USER的基础上可以修改，添加用户信息，SUPER_ADMIN可以删除。**  我们需要知道三个实体类之间的关系，User与Role一对一，Role与Permissions一对一，当然也可以把它都写成多对多，这就需要去更改数据库文件，和实体类了。\n持久层可以使用lombok，让我们可以减少持久类的代码量，减少set，get的编写。\n\n**sql代码：**\n```sql\n-- ----------------------------\n-- Table structure for role\n-- ----------------------------\nCREATE TABLE `role`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '角色表主键',\n  `role_name` varchar(32) DEFAULT NULL COMMENT '角色名称',\n  PRIMARY KEY (`id`)\n);\n\n-- ----------------------------\n-- Records of role\n-- ----------------------------\nINSERT INTO `role` VALUES (1, 'SUPER_ADMIN');\nINSERT INTO `role` VALUES (2, 'ADMIN');\nINSERT INTO `role` VALUES (3, 'USER');\n\n-- ----------------------------\n-- Table structure for user\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键',\n  `username` varchar(32) NOT NULL COMMENT '用户名',\n  `password` varchar(32) NOT NULL COMMENT '密码',\n  `role_id` int(11) DEFAULT NULL COMMENT '与role角色表联系的外键',\n  PRIMARY KEY (`id`),\n  CONSTRAINT `user_role_on_role_id` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`)\n);\n\n-- ----------------------------\n-- Records of user\n-- ----------------------------\nINSERT INTO `user` VALUES (1, 'BWH_Steven', '666666', 1);\nINSERT INTO `user` VALUES (2, 'admin', '666666', 2);\nINSERT INTO `user` VALUES (3, 'zhangsan', '666666', 3);\n\n-- ----------------------------\n-- Table structure for permission\n-- ----------------------------\nCREATE TABLE `permission`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '权限表主键',\n  `permission_name` varchar(50) NOT NULL COMMENT '权限名',\n  `role_id` int(11) DEFAULT NULL COMMENT '与role角色表联系的外键',\n  PRIMARY KEY (`id`),\n  CONSTRAINT `permission_role_on_role_id` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`)\n);\n\n-- ----------------------------\n-- Records of permission\n-- ----------------------------\nINSERT INTO `permission` VALUES (1, 'user:*', 1);\nINSERT INTO `permission` VALUES (2, 'user:*', 2);\nINSERT INTO `permission` VALUES (3, 'user:queryAll', 3);\n\n```\n* entity层比较简单，不贴代码：\n\n\n#### （2）接下来就是pom.xml添加相关依赖，这里就不贴代码了,需要的github自取。\n\n\n#### （3）整合mybatis和springboot：\n\n就只需要创建一个dao层，一个服务层,需要记住要添加注解，一定要清楚他们的对应关系：\n\n**①  mapper配置文件(也可以使用注解形式)：**\n\n**UserMapper.xml代码**\n\n```java \n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.example.csy.dao.UserMapper\">\n\n    <select id=\"queryUserByUsername\" resultMap=\"userRoleMap\">\n        SELECT u.*,r.role_name FROM `user` u, `role` r\n          WHERE username = #{username} AND u.role_id = r.id;\n    </select>\n    <!-- 定义封装 User和 role 的 resultMap -->\n    <resultMap id=\"userRoleMap\" type=\"com.example.csy.entity.User\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"username\" column=\"username\"></result>\n        <result property=\"password\" column=\"password\"></result>\n        <result property=\"roleId\" column=\"role_id\"></result>\n        <!-- 配置封装 UserPojo 的内容 -->\n        <association property=\"role\" javaType=\"com.example.csy.entity.Role\">\n            <id property=\"id\" column=\"id\"></id>\n            <result property=\"roleName\" column=\"role_name\"></result>\n        </association>\n    </resultMap>\n\n\n    <select id=\"queryPermissionByUsername\" resultMap=\"permissionRoleMap\">\n        SELECT p.* ,r.role_name FROM `user` u, `role` r, `permission` p\n          WHERE username = #{username} AND u.role_id = r.id AND p.role_id = r.id;\n    </select>\n    <!-- 定义封装 permission 和 role 的 resultMap -->\n    <resultMap id=\"permissionRoleMap\" type=\"com.example.csy.entity.Permissions\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"permissionName\" column=\"permission_name\"></result>\n        <result property=\"roleId\" column=\"role_id\"></result>\n        <!-- 配置封装 Role 的内容 -->\n        <association property=\"role\" javaType=\"com.example.csy.entity.Role\">\n            <id property=\"id\" column=\"id\"></id>\n            <!--property是实体类中被赋值的参数名，column是数据库的列名-->\n            <result property=\"roleName\" column=\"role_name\"></result>\n        </association>\n    </resultMap>\n</mapper>\n```\n\n**② dao层与service也比较简单。**\n\n\n**③ 弄到这里我们的mybatis+springboot整合也基本结束，所以在测试类里测试一下：**\n\n```java\n@SpringBootTest\nclass CsyApplicationTests {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    void contextLoads() {\n        User admin = userMapper.queryUserByUsername(\"admin\");\n        System.out.println(admin.toString());\n        Permissions permission = userMapper.queryPermissionByUsername(\"admin\");\n        System.out.println(permission.toString());\n    }\n}\n```\n\n#### （4）将shiro整合到项目里：\n\n**①.shiro最关键的就是Realm组件：**\n\n其可以理解为 Shiro 与 数据之间的沟通器与中间桥梁认证授权时，就会去此部分找一些内容，从本质上 Realm 就是一个经过了大量封装的安全 Dao，这是官网的介绍，我的理解对于Realm组件其实就是一个Dao，我们在这里面定义两个方法，一个身份认证doGetAuthenticationInfo，一个授权doGetAuthorizationInfo，这两个方法很关键，所以给出全部代码：\n\n***UserRealm代码：\n```java\npublic class UserRealm extends AuthorizingRealm {\n\n    @Autowired\n    private UserMapper userMapper;\n    /**\n     * @MethodName doGetAuthorizationInfo 授权操作\n     * @Description 权限配置类\n     * @Param [principalCollection]\n     * @Return AuthorizationInfo\n     */\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        // 获取用户名信息\n        String username = (String) principalCollection.getPrimaryPrincipal();\n        // 创建一个简单授权验证信息\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        // 给这个用户设置从 role 表获取到的角色信息\n        authorizationInfo.addRole(userMapper.queryUserByUsername(username).getRole().getRoleName());\n        //给这个用户设置从 permission 表获取的权限信息\n        authorizationInfo.addStringPermission(userMapper.queryPermissionByUsername(username).getPermissionName());\n        return authorizationInfo;\n    }\n    /**\n     * @MethodName doGetAuthenticationInfo 身份验证\n     * @Description 认证配置类\n     * @Param [authenticationToken]\n     * @Return AuthenticationInfo\n     * @Author WangShiLin\n     */\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        // 根据在接受前台数据创建的 Token 获取用户名\n        String username = (String) authenticationToken.getPrincipal();\n        // 通过用户名查询相关的用户信息（实体）\n        User user = userMapper.queryUserByUsername(username);\n        if (user != null) {\n            // 存入 Session，可选\n            SecurityUtils.getSubject().getSession().setAttribute(\"user\", user);\n            // 密码认证的工作，Shiro 来做\n            AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), \"userRealm\");\n            return authenticationInfo;\n        } else {\n            // 返回 null 即会抛异常\n            return null;\n        }\n    }\n}\n```\n\n**②接下来就是编写ShiroConfig注解类：**\n\n将所有类，属性全部注入spring容器中，但是我们使用springboot，直接使用注解：@Configuration。\n该注解类主要是要将，realm类的两个自定义的方法注入，还有配置安全管理器 SecurityManager，还有就是过滤器，这个过滤器是分配权限的一个关键方法，对于这个过滤器，shiro有一个封装好的ShiroFilterFactoryBean工厂类，他有很多自定义方法，set登录页，成功页，未授权页等，这个通过springMvc的控制器控制就行。\n重点说一下拦截放行（Map）这块：通过 map 键值对的形式存储，key 存储 URL ，value 存储对应的一些权限或者角色等等，其实 key 这块还是很好理解的，例如 ：/css/**、/user/admin/** 分别代表 css 文件夹下的所有文件，以及请求路径前缀为 /user/admin/ URL，而对应的 value 就有一定的规范了。\n如下面的一些shiro自定好的权限\n\n**关键：\nanon：无需认证，即可访问，也就是游客也可以访问\nauthc：必须认证，才能访问，也就是例如需要登录后\nroles[xxx] ：比如拥有某种角色身份才能访问 ，注：xxx为角色参数\nperms[xxx]：必须拥有对某个请求、资源的相关权限才能访问，注：xxx为权限参数**\n\n就比如我们自己的图片，static文件下所有数据都可以直接使用anon，直接放行，不用管理。\n\n**shiroConfig配置类的所有代码：**\n```java\n\n\n@Configuration\npublic class ShiroConfig {\n\n    //将自己的验证方式加入容器\n    @Bean\n    public UserRealm myShiroRealm() {\n        return new UserRealm();\n    }\n    /**\n     * 配置安全管理器 SecurityManager\n     *\n     * @return\n     */\n    @Bean\n    public DefaultWebSecurityManager securityManager() {\n        // 将自定义 Realm 加进来\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        // 关联 Realm\n        securityManager.setRealm(myShiroRealm());\n        return securityManager;\n    }\n    /**\n     * 配置 Shiro 过滤器\n     *\n     * @param securityManager\n     * @return\n     */\n    @Bean\n    public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager) {\n        // 定义 shiroFactoryBean\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n        // 关联 securityManager\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\n        // 自定义登录页面，如果登录的时候，就会执行这个请求，即跳转到登录页\n        shiroFilterFactoryBean.setLoginUrl(\"/toLoginPage\");\n        // 指定成功页面\n        shiroFilterFactoryBean.setSuccessUrl(\"/success\");\n        // 指定未授权界面\n        shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorized\");\n        // 设置自定义 filter\n        Map<String, Filter> filterMap = new LinkedHashMap<>();\n        filterMap.put(\"anyRoleFilter\", new MyRolesAuthorizationFilter());\n        shiroFilterFactoryBean.setFilters(filterMap);\n        // LinkedHashMap 是有序的，进行顺序拦截器配置\n        Map<String, String> filterChainMap = new LinkedHashMap<>();\n        // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon 表示放行\n        filterChainMap.put(\"/css/**\", \"anon\");\n        filterChainMap.put(\"/img/**\", \"anon\");\n        filterChainMap.put(\"/js/**\", \"anon\");\n        // 指定页面放行，例如登录页面允许所有人登录\n        filterChainMap.put(\"/toLoginPage\", \"anon\");\n        // 以“/user/admin” 开头的用户需要身份认证，authc 表示要进行身份认证\n        filterChainMap.put(\"/user/admin/**\", \"authc\");\n        // 页面 -用户需要角色认证\n//        filterChainMap.put(\"/levelA/**\", \"anyRoleFilter[USER,ADMIN,SUPER_ADMIN]\");\n        filterChainMap.put(\"/levelB/**\", \"anyRoleFilter[ADMIN,SUPER_ADMIN]\");\n//        filterChainMap.put(\"/levelC/**\", \"anyRoleFilter[SUPER_ADMIN]\");\n//        filterChainMap.put(\"/levelA/**\", \"roles[USER]\");\n//        filterChainMap.put(\"/levelB/**\", \"roles[ADMIN]\");\n//        filterChainMap.put(\"/levelC/**\", \"roles[SUPER_ADMIN]\");\n        // /user/admin/ 下的所有请求都要经过权限认证，只有权限为 user:[*] 的可以访问，也可以具体设置到 user:xxx\n        filterChainMap.put(\"/user/admin/**\", \"perms[user:*]\");\n        // 配置注销过滤器\n        filterChainMap.put(\"/logout\", \"logout\");\n        // 将Map 存入过滤器\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);\n        return shiroFilterFactoryBean;\n    }\n    /**\n     * 整合 thymeleaf\n     * @return\n     */\n    @Bean(name = \"shiroDialect\")\n    public ShiroDialect shiroDialect(){\n        return new ShiroDialect();\n    }\n}\n```\n\n**④自定义一个角色认证过滤器MyRolesAuthorizationFilter：**\n\n因为我们的角色，只需用有一个角色就能访问到映射页面,shiro默认是hasAllRoles，也就是说，我们要满足所有的身份才能访问，所以需要我们自定义一个hasAnyRoles，任选其一角色即可。\n\n```java\npublic class MyRolesAuthorizationFilter extends AuthorizationFilter {\n    @SuppressWarnings({\"unchecked\"})\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {\n        Subject subject = getSubject(request, response);\n        String[] rolesArray = (String[]) mappedValue;\n        if (rolesArray == null || rolesArray.length == 0) {\n            //no roles specified, so nothing to check - allow access.\n            return false;\n        }\n        List<String> roles = CollectionUtils.asList(rolesArray);\n        boolean[] hasRoles = subject.hasRoles(roles);\n        for (boolean hasRole : hasRoles) {\n            if (hasRole) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n#### （5）将整合Thymeleaf和semantic进来：\nUi我们使用的是semantic，感觉还可以：接下来，就直接展示页面效果了：\n我们对各种角色对数据库的操作进行了权限的限制，如开头所说，USER有查询的权限，ADMIN在USER的基础上可以修改，添加用户信息，SUPER_ADMIN可以删除。\n我们实现这种操作，是对表格的一部分标签设置了部分角色才能查看：\n关键代码是index主页中标签的声明：\n\n**A.USER有查询的权限**\nshiro:hasAnyRoles=\"SUPER_ADMIN,ADMIN,USER\"\n\n**B.ADMIN在USER的基础上可以修改**\nshiro:hasAnyRoles=\"SUPER_ADMIN,ADMIN\"\n\n**C.SUPER_ADMIN在ADMIN权限上可以删除**\nshiro:hasAnyRoles=\"SUPER_ADMIN\"\n\n#### （6）最后就是controller，由于比较简单，就不写代码了。\n#### （7）shiro效果展示：\n\n**登录login.html**\n\n![login](https://gitee.com/chenqd/pic/raw/master/20201130173126.png)\n\n**USER权限:**\n\n![user](https://gitee.com/chenqd/pic/raw/master/20201130173152.png)\n\n**admin权限：**\n\n![ad](https://gitee.com/chenqd/pic/raw/master/20201130173209.png)\n\n**SUPER_ADMIN权限：**\n\n![sa](https://gitee.com/chenqd/pic/raw/master/20201130173223.png)\n\n**至此shiro实现登录的身份认证和权限分配操作已经搞定，接下来就是用户信息的增删查改：**\n\n\n## 2.2实现用户信息的增删查改：\n### （1）dao（mapper）层和service层的编写：\n由于使用的mybatis，所以我们需要有两种方式，一种是使用注解，一种是编写配置文件，在项目里，两种方式，都使用了的。\n对于两个一对多的查询使用的是配置文件形式，其他的增、删、改都是用的是注解形式,由于mapper类比较简单就不贴代码了，还有一个UserMapper.xml配置文件的代码，已经在shiro那里贴出来了，这里也不书写了。\n然后就是service类的编写，我们使用@Service注解，接口和实现类都需要@service注解，然后在实现类中通过mapper调用方法，再加上一些限制如：\n增加用户信息时，如果该用户存在，就打印失败，方法直接结束。\n\n### （2）编写测试类：\n写了测试成功之后，如果出错，我们可以不用担心是DAO层和service出错了。\n```java\n@Test\n    void queryAll(){\n        List<User> users = userService.queryAll();\n        System.out.println(users);\n    }\n\n    @Test\n    void contextLoads() {\n        User admin = userService.queryUserByUsername(\"admin\");\n        System.out.println(admin.toString());\n        Permissions permission = userService.queryPermissionByUsername(\"admin\");\n        System.out.println(permission.toString());\n    }\n    @Test\n    void addTest() {\n        User user = new User(\"wu\",\"123\",3);\n        int i = userService.addUser(user);\n        System.out.println(i);\n    }\n    @Test\n    void deleteTest() {\n        userService.deleteUser(\"zhangsan\");\n    }\n    @Test\n    void updateTest() {\n        User user = new User(\"ww\",\"123\",3);\n    }\n}\n```\n\n### （3）显示数据到主页index.html上：\n主要使用vue，axios将数据显示到页面，使用vue的指令，比如v-for，v-model等，ui使用的是semantic，bootstrap，我们将**数据操作分为四步**怎么实现的。\n\n**A.查询所有：**\n\n在mapper的定义中，我们有一个queryAll()方法，在controller中，我们返回一个List<User>，所以index中获取这个list，就是最关键的问题了，这里我们在index页面中直接把vue对象定义出来，var vm = new Vue()；将数据显示的表格定义一个id，这个id由vue代理。\n只需要在data属性里，定义一个数组userList，来将queryAll查询到的list数据赋值到userList数组里。\n当然查询这个方法，按我们的一般体验来说，应该要登录了就显示，所以axios就起到作用了，他可以让我们不用刷新就把数据显示到页面上，而且在vue中使用axios也比较的方便。\n我们需要考虑一个问题，就是查询操作应该多久显示，我们知道vue对象使用声明周期的，我们可以在创建vue对象之后就调用queryAll方法，这样就可以实现一登录就查询所有的操作了。\n在这里我们只需要在vue对象中添加两个方法，一个queryAll，一个create方法。需要值得注意的是我们给userList赋值时，需要声明一个变量 var _this = this;因为vue对象，和axios是不一样的，只有将this赋值，才会调用vue中的对象userList，不然则会调用axios的this，当然我们没有写，所以如果这样写出来，会发现什么数据都没有。\n赋值userList后，就只需要展示，使用v-for指令，和取值符号就解决了。\n\n**Vue代码部分：**\n```js\n    var vm = new Vue({\n        el: \"#app\",\n        data: {\n            user: {id:\"\",\n                username:\"\",\n                password:\"\",\n                roleId:\"\",\n                role:{id:\"\",roleName:\"\"}\n                },\n            userList: [],\n            wo:\"ri\"\n        },\n        methods: {\n            addUser:function (user) {\n                var _this = this;\n                axios.post(\"/user/admin/add\",_this.user).then(function (response) {\n                    _this.queryAll();\n                    console.log(_this.userList);\n                }).catch(function (err) {\n                    console.log(_this.user);\n                    console.log(err);\n                });\n            },\n            deleteUser:function (username) {\n                var _this = this;\n                axios.post(\"/user/admin/delete\",username=username).then(function (response) {\n                    _this.queryAll();\n                }).catch(function (err) {\n                });\n            },\n            queryAll: function () {\n                var _this = this;\n                axios.get(\"/user/queryAll\").then(function (response) {\n                    _this.userList = response.data;\n                    console.log(_this.userList);\n                }).catch(function (err) {\n                    console.log(err);\n                });\n            },\n            queryByName: function (username) {\n                var _this = this;\n                axios.get(\"/user/queryByName\", {\n                    params: {\n                        username: username\n                    }\n                }).then(function (response) {\n                    _this.user = response.data;\n                    $('#updateModal').modal(\"show\");\n                    console.log(_this.user);\n                }).catch(function (err) {\n                    console.log(err);\n                });\n            },\n            updateUser: function (user) {\n                var _this = this;\n                axios.post(\"/user/admin/update\",_this.user).then(function (response) {\n                    _this.queryAll();\n                    console.log(_this.user);\n                }).catch(function (err) {\n                });\n            }\n        },\n        created(){\n            this.queryAll();\n        }\n    });\n```\n\n**Html表格那部分代码比较简单就不贴了。**\n\n**B.删除用户：**\n\n对于删除用户，我们可以再每个查询结果后弄一个td，这样我们就可以获取当前这一行的user的id，方便赋值，这里我们使用v-on：，直接调用vue中定义的方法deleteUser（id），在这里我们也使用axios.post()，因为我们要传参数，执行操作，deleteUser方法的代码就在上面，同时我们需要在执行完操作之后，直接查询所有方法queryAll，所以我们需要在delete结束后，调用_this.queryAll()方法。这样交互性比较好。\n\n\n**C.修改用户：**\n\n修改用户我们可以使用bootstrap中的模态框，使用模态框的好处，就是交互性好，不需要跳转页面，使用起来更加简洁。使用模态框也不是很难，就只需要在div标签中的class使用bootstrap的语法，在点击修改之后，会调用queryByName方法，在方法中使用取值符号来获取模态框的id并且调用bootstrap封装的moal(“show)方法，显示模态框。\n_this.user = response.data;$('#updateModal').modal(\"show\");\n\n\n**E.增加用户：**\n\n增加用户和修改用户差不多，也是v-model实现，只不过加了提示，当然后续操作和上面一样，也是直接queryAll(),还有一点因为网页传给我们的数据时json，所以需要在controller中使用@RequestBody将json转换成字符串，如果有返回值也要使用@ResponseBody。因为要赋值。\n\n![add](https://gitee.com/chenqd/pic/raw/master/20201130173255.png)\n**到此开发就结束了。**\n\n## 四、实验成果展示：\n\n实现的效果大家可以克隆下来源代码自己测试，这里我只给出一些大概的展示。\n（1）增加用户：\n![a](https://gitee.com/chenqd/pic/raw/master/20201130173313.png)\n\n\n**本博客内容基本到此结束，如果觉得有用的，你懂得，码字不易！嘻嘻！**","tags":["spring boot","shiro","thymeleaf","ssm","vue","axios","bootstrap"],"categories":["java","ssm"]},{"title":"Tomcat&Servlet","url":"/2024/01/06/Tomcat&Servlet/","content":"\n一.Tomcat:\n1. web服务软件，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。  <!--more-->\n2. 修改端口号:在conf/server.xml,也可以在idea中修改\n3. 部署web项目的方法有三种\n    * 直接将项目放到webapps目录下即可。\n    * 配置conf/server.xml文件\n    * 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写<Context docBase=\"D:\\hello\" />* 虚拟目录：xml文件的名称\n\n部署项目到idea中，new project，java ee。然后去配置tomcat的配置文件\n\n\n二.Servlet:\n1. 实现：\n   1. 定义一个类，实现Servlet接口：public class ServletDemo1 implements Servlet\n   2. 实现接口方法\n   3. 去web.xml去配置Servlet\n\n\n```xml\n<!--配置Servlet -->\n\t\t    <servlet>\n\t\t        <servlet-name>demo1</servlet-name>\n\t\t        <servlet-class>cn.itcast.web.servlet.ServletDemo1</servlet-class>\n\t\t    </servlet>\n\t\t\n\t\t    <servlet-mapping>\n\t\t        <servlet-name>demo1</servlet-name>\n\t\t        <url-pattern>/demo1</url-pattern>\n\t\t    </servlet-mapping>\n    \n```\n\n\n2. 执行原理：\n   ![QQ截图20200827230403.png](http://ww1.sinaimg.cn/large/006ncldEgy1gi5rotvonhj31af0i6q49.jpg)\n\n\n   1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\n   2. 查找web.xml文件，是否有对应的<url-pattern>标签体内容。\n   3. 如果有，则在找到对应的<servlet-class>全类名\n   4. tomcat会将字节码文件加载进内存，并且创建其对象\n   5. 调用其方法\n\n也可以用Servlet3，在创建项目时可以选择，\n用Servlet3就比较简单，不用去配置web.xml文件，只需要注解配置,其中/demo就是urlPatterns()，和在web.xml配置的原理一样。\n\n```xml\n@WebServlet(\"/demo\")\npublic class ser implements Servlet{\n\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n        System.out.println(\"init\");\n    }\n```\n\n3. Servlet中的生命周期方法：\n   1. 被创建：执行init方法，只执行一次\n   \t* 默认情况下，第一次被访问时，Servlet被创建\n   \t* 可以配置执行Servlet的创建时机。在<servlet>标签下配置\n   \t\t1. 第一次被访问时，创建: `<load-on-startup>`的值为负数\n        1. 在服务器启动时，创建: `<load-on-startup>`的值为0或正整数\n\n\n   2. Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是**单例**的。\n   \t多个用户同时访问时，可能存在线程安全问题。\n    解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值。比如买票，定义个成员变量，他就会共享。如果同时买票，或者退票，就会出现问题。\n\n   3. 提供服务：执行service方法，执行多次:每次访问Servlet时，Service方法都会被调用一次。\n   4. 被销毁：执行destroy方法，只执行一次。\n        Servlet被销毁时执行。服务器关闭时，Servlet被销毁，\n        只有服务器正常关闭时，才会执行destroy方法。\n        destroy方法在Servlet被销毁之前执行，一般用于释放资源。\n","tags":["tomcat","servlet"],"categories":["java"]},{"title":"不用梯子也能用谷歌搜索","url":"/2024/01/06/不用梯子也能用谷歌搜索/","content":"\n谷歌——程序员必备工具。但是谷歌引擎被墙了，内地是用不了的。<!--more-->\n## 1.下载Ghelper：\n[官方地址](http://googlehelper.net/)\n![QQ截图20200817143359.png](https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzAwNm5jbGRFZ3kxZ2h0c3I3cWxmc2ozMHRjMGh2Z25pLmpwZw?x-oss-process=image/format,png)\n## 2.添加扩展\n![屏幕截图(9)_LI.jpg](https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzAwNm5jbGRFZ3kxZ2h0c3UxajgwbGozMGp1MGg2aDQ5LmpwZw?x-oss-process=image/format,png)\n\n![QQ截图20200817143837.png](https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzAwNm5jbGRFZ3kxZ2h0c3dlYzBrd2ozMWg5MDRtanJmLmpwZw?x-oss-process=image/format,png)\n把Ghelper文件夹拖过来，或者是添加已解压文件。之后就能顺利使用谷歌搜索引擎了。\n\n","tags":["谷歌"],"categories":["工具","谷歌"]},{"title":"SpringBoot+shiro+mybatis+Thymeleaf实现权限登录","url":"/2024/01/06/SpringBoot+shiro+mybatis+Thymeleaf实现权限登录/","content":"最近在做一个期末作品，就是使用ssm+thymeleaf+vue+shiro完成一个具有**权限登录，且能实现用户信息增删查改**的这么一个项目，下面仅仅是实现**权限认证和登录**。为什么我选shiro，而不选spring Security，是因为我试过，security实在是比较难，封装的太厉害了，哈哈哈哈，所以果断放弃，选择shiro进行。<!--more-->\n\n下一篇还实现了增删查改，使用vue，但是没有前后端分离，[博客链接](https://blog.csdn.net/weixin_46509714/article/details/110392288)\n\n[!github源码连接](https://github.com/chenQD123/SSM/tree/master)，需要请自行下载。\n\n提示，这个项目已经有了增删查改，跟着下面的博客做，也能做出来页面跳转权限，但是没有增删查改。\n\n\n\n以下是学习shiro的一个小Demo：\n\n### 1.首先是底层数据库：\n```sql\n-- ----------------------------\n-- Table structure for role\n-- ----------------------------\nCREATE TABLE `role`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '角色表主键',\n  `role_name` varchar(32) DEFAULT NULL COMMENT '角色名称',\n  PRIMARY KEY (`id`)\n);\n\n-- ----------------------------\n-- Records of role\n-- ----------------------------\nINSERT INTO `role` VALUES (1, 'SUPER_ADMIN');\nINSERT INTO `role` VALUES (2, 'ADMIN');\nINSERT INTO `role` VALUES (3, 'USER');\n\n-- ----------------------------\n-- Table structure for user\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键',\n  `username` varchar(32) NOT NULL COMMENT '用户名',\n  `password` varchar(32) NOT NULL COMMENT '密码',\n  `role_id` int(11) DEFAULT NULL COMMENT '与role角色表联系的外键',\n  PRIMARY KEY (`id`),\n  CONSTRAINT `user_role_on_role_id` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`)\n);\n\n-- ----------------------------\n-- Records of user\n-- ----------------------------\nINSERT INTO `user` VALUES (1, 'BWH_Steven', '666666', 1);\nINSERT INTO `user` VALUES (2, 'admin', '666666', 2);\nINSERT INTO `user` VALUES (3, 'zhangsan', '666666', 3);\n\n-- ----------------------------\n-- Table structure for permission\n-- ----------------------------\nCREATE TABLE `permission`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '权限表主键',\n  `permission_name` varchar(50) NOT NULL COMMENT '权限名',\n  `role_id` int(11) DEFAULT NULL COMMENT '与role角色表联系的外键',\n  PRIMARY KEY (`id`),\n  CONSTRAINT `permission_role_on_role_id` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`)\n);\n\n-- ----------------------------\n-- Records of permission\n-- ----------------------------\nINSERT INTO `permission` VALUES (1, 'user:*', 1);\nINSERT INTO `permission` VALUES (2, 'user:*', 2);\nINSERT INTO `permission` VALUES (3, 'user:queryAll', 3);\n\n```\n\n### 2.创建spring boot项目，用maven构建\n创建实体类（User，Role，Permissions）：\n**User:**\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n    private Integer id;\n    private String username;\n    private String password;\n    //用户对应的角色集合\n    private Role role;\n}\n```\n\n**Role:**\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Role {\n    private Integer id;\n    private String roleName;\n\n\n}\n```\n\n**Permissions：**\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Permissions {\n    private Integer id;\n    private String permissionName;\n    private Role role;\n}\n\n```\n\n我们需要知道三个实体类之间的关系，User与Role一对一，Role与Permissions一对一，当然也可以把它都写成多对多，这就需要去更改数据库文件，和实体类了。\n\n### 3.在pom.xml添加相关依赖：\n\n下面只给出相关依赖源\n```xml\n<dependency>\n            <groupId>com.github.theborakompanioni</groupId>\n            <artifactId>thymeleaf-extras-shiro</artifactId>\n            <version>2.0.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.shiro</groupId>\n            <artifactId>shiro-spring</artifactId>\n            <version>1.5.3</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n            <version>2.1.3</version>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n```\n\n### 4.整合mybatis和springboot：\n就只需要创建一个dao层，一个服务层,需要记住要**添加注解**：\n（1)mapper配置文件(也可以使用注解形式)：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.example.csy.dao.UserMapper\">\n\n    <select id=\"queryUserByUsername\" resultMap=\"userRoleMap\">\n        SELECT u.*,r.role_name FROM `user` u, `role` r\n          WHERE username = #{username} AND u.role_id = r.id;\n    </select>\n    <!-- 定义封装 User和 role 的 resultMap -->\n    <resultMap id=\"userRoleMap\" type=\"com.example.csy.entity.User\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"username\" column=\"username\"></result>\n        <result property=\"password\" column=\"password\"></result>\n        <!-- 配置封装 UserPojo 的内容 -->\n        <association property=\"role\" javaType=\"com.example.csy.entity.Role\">\n            <id property=\"id\" column=\"id\"></id>\n            <result property=\"roleName\" column=\"role_name\"></result>\n        </association>\n    </resultMap>\n\n\n    <select id=\"queryPermissionByUsername\" resultMap=\"permissionRoleMap\">\n        SELECT p.* ,r.role_name FROM `user` u, `role` r, `permission` p\n          WHERE username = #{username} AND u.role_id = r.id AND p.role_id = r.id;\n    </select>\n    <!-- 定义封装 permission 和 role 的 resultMap -->\n    <resultMap id=\"permissionRoleMap\" type=\"com.example.csy.entity.Permissions\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"permissionName\" column=\"permission_name\"></result>\n        <!-- 配置封装 Role 的内容 -->\n        <association property=\"role\" javaType=\"com.example.csy.entity.Role\">\n            <id property=\"id\" column=\"id\"></id>\n            <!--property是实体类中被赋值的参数名，column是数据库的列名-->\n            <result property=\"roleName\" column=\"role_name\"></result>\n        </association>\n    </resultMap>\n</mapper>\n\n```\n（2）DAO层：\n```java\n@Mapper\npublic interface UserMapper {\n    User queryUserByUsername(@Param(\"username\") String username);\n\n    Permissions queryPermissionByUsername(@Param(\"username\") String username);\n}\n```\n\n（3）service层：\n```java\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public User queryUserByUsername(String username) {\n\n        return userMapper.queryUserByUsername(username);\n    }\n\n    @Override\n    public Permissions queryPermissionByUsername(String username) {\n        return userMapper.queryPermissionByUsername(username);\n    }\n}\n\n```\n\n弄到这里，我们的mybatis+springboot整合也基本结束，所以在测试类里测试一下：\n```java\n@SpringBootTest\nclass CsyApplicationTests {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    void contextLoads() {\n        User admin = userMapper.queryUserByUsername(\"admin\");\n        System.out.println(admin.toString());\n        Permissions permission = userMapper.queryPermissionByUsername(\"admin\");\n        System.out.println(permission.toString());\n    }\n}\n```\n\n**测试结果：**\n得到了查询结果\n\n![QQ截图20201120111727.png](http://ww1.sinaimg.cn/large/006ncldEgy1gkvjx25b9uj30ne021t8l.jpg)\n\n\n### 6.整合Thymeleaf进来：\n**前端页面：**\n在html页面我们整合了Thymeleaf，使用了Jquery，semantic，需要导包\n![QQ截图20201120131847.png](http://ww1.sinaimg.cn/large/006ncldEgy1gkvkfr7zrmj308d070q2w.jpg)\n![QQ截图20201120131359.png](http://ww1.sinaimg.cn/large/006ncldEgy1gkvkaskpxvj309a0er3yo.jpg)\n\n**index.html代码：**\n在这里，如果是User就只能访问A，Admin能访问A,B，superAdmin能访问A,B,C\n```html\n<!DOCTYPE html>\n<html lang=\"zh_CN\"\n      xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:layout=\"http://www.ultraq.net.nz/web/thymeleaf/layout\"\n      xmlns:shiro=\"http://www.pollix.at/thymeleaf/shiro\"\n>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>信息管理平台-首页</title>\n    <meta\n            name=\"viewport\"\n            content=\"width=device-width, initial-scale=1, maximum-scale=1\"\n    />\n    <title>首页</title>\n    <!--semantic-ui-->\n    <link\n            href=\"https://cdn.bootcss.com/semantic-ui/2.4.1/semantic.min.css\"\n            rel=\"stylesheet\"\n    />\n\n    <!--<link href=\"css/index.css\" rel=\"stylesheet\">-->\n    <link th:href=\"@{/css/index.css}\" rel=\"stylesheet\">\n\n    <!-- <script th:src=\"@{js/jquery-3.1.1.min.js}\"></script> -->\n    <script src=\"js/jquery-3.1.1.min.js\"></script>\n</head>\n<body>\n<div class=\"ui container\">\n    <div class=\"ui secondary menu\">\n        <a class=\"active item\" th:href=\"@{/index}\">\n            首页\n        </a>\n\n        <a class=\"active item\" th:href=\"@{/about}\">\n            关于\n        </a>\n        <!--登录注销-->\n        <div class=\"right menu\">\n\n            <!--如果未登录-->\n            <!--<div shiro:authorize=\"!isAuthenticated()\">-->\n            <div shiro:notAuthenticated=\"\">\n                <a class=\"item\" th:href=\"@{/toLoginPage}\">\n                    <i class=\"address card icon\"></i> 登录\n                </a>\n            </div>\n\n            <!--如果已登录-->\n            <div shiro:authenticated=\"\">\n                <a class=\"item\">\n                    <i class=\"address card icon\"></i>\n                    用户名：<span shiro:principal></span>\n                    <!--角色：<span sec:authentication=\"principal.authorities\"></span>-->\n                </a>\n            </div>\n\n            <div shiro:authenticated=\"\">\n                <a class=\"item\" th:href=\"@{/logout}\">\n                    <i class=\"address card icon\"></i> 注销\n                </a>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"ui stackable three column grid\">\n        <div class=\"column\" shiro:hasAnyRoles=\"USER,ADMIN,SUPER_ADMIN\"><!--有其中任一一个角色课访问-->\n            <div class=\"ui raised segments\">\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelA/a}\">L-A-a</a>\n                </div>\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelA/b}\">L-A-b</a>\n                </div>\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelA/c}\">L-A-c</a>\n                </div>\n            </div>\n        </div>\n        <div class=\"column\" shiro:hasAnyRoles=\"ADMIN,SUPER_ADMIN\">\n            <div class=\"ui raised segments\">\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelB/a}\">L-B-a</a>\n                </div>\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelB/b}\">L-B-b</a>\n                </div>\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelB/c}\">L-B-c</a>\n                </div>\n            </div>\n        </div>\n        <div class=\"column\" shiro:hasRole=\"SUPER_ADMIN\">\n            <div class=\"ui raised segments\">\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelC/a}\">L-C-a</a>\n                </div>\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelC/b}\">L-C-b</a>\n                </div>\n                <div class=\"ui segment\">\n                    <a th:href=\"@{/levelC/c}\">L-C-c</a>\n                </div>\n            </div>\n        </div>\n        <!-- <div class=\"column\"></div> -->\n    </div>\n\n    <div class=\"ui stacked segment\">\n        <div class=\"ui stackable three column grid\">\n            <div class=\"column\">\n                <p>\n                    晚风吹起你鬓间的白发<br/>\n                    抚平回忆留下的疤<br/>\n                    你的眼中 明暗交杂 一笑生花<br/>\n                    暮色遮住你蹒跚的步伐<br/>\n                    走进床头藏起的画<br/>\n                    画中的你 低着头说话<br/>\n                    我仍感叹于世界之大\n                </p>\n            </div>\n\n            <div class=\"column\">\n                <p>\n\n                    也沉醉于儿时情话<br/>\n                    不剩真假 不做挣扎 无谓笑话<br/>\n                    我终将青春还给了她<br/>\n                    连同指尖弹出的盛夏<br/>\n                    心之所动 就随风去了<br/>\n                    以爱之名 你还愿意吗<br/>\n                    ❤\n                </p>\n            </div>\n            <div class=\"column\">\n                <img class=\"ui medium circular image\" src=\"images/001.jpg\">\n            </div>\n        </div>\n\n    </div>\n\n    <div class=\"ui info message\">\n        <div class=\"header\">理想二旬不止</div>\n        <p>BWH_Steven</p>\n    </div>\n</div>\n\n</body>\n</html>\n```\n\n**login.html代码：**\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:layout=\"http://www.ultraq.net.nz/web/thymeleaf/layout\"\n>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>用户管理系统-登录</title>\n    <!-- <script th:src=\"@{js/jquery-3.1.1.min.js}\"></script> -->\n    <script src=\"js/jquery-3.1.1.min.js\"></script>\n    <link\n            href=\"https://cdn.bootcss.com/semantic-ui/2.4.1/semantic.min.css\"\n            rel=\"stylesheet\"\n    />\n</head>\n<body>\n<h1>用户管理系统-登录</h1>\n<div class=\"ui container\" style=\"margin-top: 180px;\">\n    <div style=\"text-align: center; margin-bottom: 20px;\">\n        <h1 class=\"header\">\n            登录\n        </h1>\n    </div>\n\n    <div class=\"ui three column stackable grid login-div\">\n        <div class=\"column\"></div>\n        <div class=\"column\">\n            <form id=\"login\" class=\"ui fluid form segment\" th:action=\"@{/login}\" method=\"post\">\n                <div class=\"field\">\n                    <label class=\"\">用户名</label>\n                    <div class=\"ui left icon input\">\n                        <input type=\"text\" name=\"username\" placeholder=\"\"/>\n                        <i class=\"user icon\"></i>\n                        <div class=\"ui corner label\">\n                            <i class=\"icon asterisk\"></i>\n                        </div>\n                    </div>\n                </div>\n                <div class=\"field\">\n                    <label class=\"\">密码</label>\n                    <div class=\"ui left icon input\">\n                        <input type=\"password\" name=\"password\" placeholder=\"\"/>\n                        <i class=\"lock icon\"></i>\n                        <div class=\"ui corner label\">\n                            <i class=\"icon asterisk\"></i>\n                        </div>\n                    </div>\n                </div>\n                <div class=\"inline field\">\n                    <div class=\"ui checkbox\">\n                        <input type=\"checkbox\" name=\"terms\"/>\n                        <label>记住密码</label>\n                    </div>\n                </div>\n                <div class=\"inline field\">\n                    <input type=\"submit\" class=\"ui blue submit button\">\n                </div>\n            </form>\n        </div>\n        <div class=\"column\"></div>\n    </div>\n</div>\n\n\n</body>\n</html>\n```\nsuccess.html:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>用户管理系统-成功</title>\n</head>\n<body>\n<h2>登录成功</h2>\n<a href=\"/index\">返回主页</a>\n</body>\n</html>\n```\n\n\n\n### 7.将shiro整合到项目里：\n#### （1）自定义Realm：\n我们需要自定义，认证和授权：\n```java\npublic class UserRealm extends AuthorizingRealm {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    /**\n     * @MethodName doGetAuthorizationInfo 授权操作\n     * @Description 权限配置类\n     * @Param [principalCollection]\n     * @Return AuthorizationInfo\n     */\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        // 获取用户名信息\n        String username = (String) principalCollection.getPrimaryPrincipal();\n        // 创建一个简单授权验证信息\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        // 给这个用户设置从 role 表获取到的角色信息\n        authorizationInfo.addRole(userMapper.queryUserByUsername(username).getRole().getRoleName());\n        //给这个用户设置从 permission 表获取的权限信息\n        authorizationInfo.addStringPermission(userMapper.queryPermissionByUsername(username).getPermissionName());\n        return authorizationInfo;\n    }\n\n    /**\n     * @MethodName doGetAuthenticationInfo 身份验证\n     * @Description 认证配置类\n     * @Param [authenticationToken]\n     * @Return AuthenticationInfo\n     * @Author WangShiLin\n     */\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        // 根据在接受前台数据创建的 Token 获取用户名\n        String username = (String) authenticationToken.getPrincipal();\n\n//        UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken;\n//        System.out.println(userToken.getPrincipal());\n//        System.out.println(userToken.getUsername());\n//        System.out.println(userToken.getPassword());\n\n        // 通过用户名查询相关的用户信息（实体）\n        User user = userMapper.queryUserByUsername(username);\n        if (user != null) {\n            // 存入 Session，可选\n            SecurityUtils.getSubject().getSession().setAttribute(\"user\", user);\n            // 密码认证的工作，Shiro 来做\n            AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), \"userRealm\");\n            return authenticationInfo;\n        } else {\n            // 返回 null 即会抛异常\n            return null;\n        }\n    }\n}\n\n```\n\n#### (2)写配置类shiroConfig：\n```java\n@Configuration\npublic class ShiroConfig {\n\n    //将自己的验证方式加入容器\n    @Bean\n    public UserRealm myShiroRealm() {\n        return new UserRealm();\n    }\n\n    /**\n     * 配置安全管理器 SecurityManager\n     *\n     * @return\n     */\n    @Bean\n    public DefaultWebSecurityManager securityManager() {\n        // 将自定义 Realm 加进来\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        // 关联 Realm\n        securityManager.setRealm(myShiroRealm());\n        return securityManager;\n    }\n\n    /**\n     * 配置 Shiro 过滤器\n     *\n     * @param securityManager\n     * @return\n     */\n    @Bean\n    public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager) {\n        // 定义 shiroFactoryBean\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n\n        // 关联 securityManager\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\n\n        // 自定义登录页面，如果登录的时候，就会执行这个请求，即跳转到登录页\n        shiroFilterFactoryBean.setLoginUrl(\"toLoginPage\");\n        // 指定成功页面\n        shiroFilterFactoryBean.setSuccessUrl(\"/success\");\n        // 指定未授权界面\n        shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorized\");\n\n        // 设置自定义 filter\n        Map<String, Filter> filterMap = new LinkedHashMap<>();\n        filterMap.put(\"anyRoleFilter\", new MyRolesAuthorizationFilter());\n        shiroFilterFactoryBean.setFilters(filterMap);\n\n        // LinkedHashMap 是有序的，进行顺序拦截器配置\n        Map<String, String> filterChainMap = new LinkedHashMap<>();\n\n        // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon 表示放行\n        filterChainMap.put(\"/css/**\", \"anon\");\n        filterChainMap.put(\"/img/**\", \"anon\");\n        filterChainMap.put(\"/js/**\", \"anon\");\n        // 指定页面放行，例如登录页面允许所有人登录\n        filterChainMap.put(\"/toLoginPage\", \"anon\");\n\n        // 以“/user/admin” 开头的用户需要身份认证，authc 表示要进行身份认证\n        filterChainMap.put(\"/user/admin/**\", \"authc\");\n\n        // 页面 -用户需要角色认证\n        filterChainMap.put(\"/levelA/**\", \"anyRoleFilter[USER,ADMIN,SUPER_ADMIN]\");\n        filterChainMap.put(\"/levelB/**\", \"anyRoleFilter[ADMIN,SUPER_ADMIN]\");\n        filterChainMap.put(\"/levelC/**\", \"anyRoleFilter[SUPER_ADMIN]\");\n\n//        filterChainMap.put(\"/levelA/**\", \"roles[USER]\");\n//        filterChainMap.put(\"/levelB/**\", \"roles[ADMIN]\");\n//        filterChainMap.put(\"/levelC/**\", \"roles[SUPER_ADMIN]\");\n\n        // /user/admin/ 下的所有请求都要经过权限认证，只有权限为 user:[*] 的可以访问，也可以具体设置到 user:xxx\n        filterChainMap.put(\"/user/admin/**\", \"perms[user:*]\");\n\n        // 配置注销过滤器\n        filterChainMap.put(\"/logout\", \"logout\");\n\n        // 将Map 存入过滤器\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);\n        return shiroFilterFactoryBean;\n    }\n\n    /**\n     * 整合 thymeleaf\n     * @return\n     */\n    @Bean(name = \"shiroDialect\")\n    public ShiroDialect shiroDialect(){\n        return new ShiroDialect();\n\n    }\n\n\n\n```\n\n首先我们将自定义的Realm方法，依赖注入进来到容器\n```java\n//将自己的验证方式加入容器\n    @Bean\n    public UserRealm myShiroRealm() {\n        return new UserRealm();\n    }\n```\n\n然后是：SecurityManager配置安全管理器\n```java\n/**\n     * 配置安全管理器 SecurityManager\n     *\n     * @return\n     */\n    @Bean\n    public DefaultWebSecurityManager securityManager() {\n        // 将自定义 Realm 加进来\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        // 关联 Realm\n        securityManager.setRealm(myShiroRealm());\n        return securityManager;\n    }\n```\n\n最后就是自定义的过滤器，控制那些页面需要什么样的角色才能访问，哪些资源需要谁才能访问，并且setSecurityManager，返回一个ShiroFilterFactoryBean。\n\n重点说一下拦截放行（Map）这块：通过 map 键值对的形式存储，key 存储 URL ，value 存储对应的一些权限或者角色等等，其实 key 这块还是很好理解的，例如 ：/css/**、/user/admin/** 分别代表 css 文件夹下的所有文件，以及请求路径前缀为 /user/admin/ URL，而对应的 value 就有一定的规范了。\n\n关键：\nanon：无需认证，即可访问，也就是游客也可以访问\nauthc：必须认证，才能访问，也就是例如需要登录后\nroles[xxx] ：比如拥有某种角色身份才能访问 ，注：xxx为角色参数\nperms[xxx]：必须拥有对某个请求、资源的相关权限才能访问，注：xxx为权限参数\n\n#### （3）自定义一个角色认证过滤器MyRolesAuthorizationFilter：\n因为我们的角色，只需用有一个角色就能访问到映射页面,shiro默认是hasAllRoles，也就是说，我们要满足所有的身份才能访问，所以需要我们自定义一个hasAnyRoles，任选其一角色即可。\n\n\n\n\n```java\npublic class MyRolesAuthorizationFilter extends AuthorizationFilter {\n\n    @SuppressWarnings({\"unchecked\"})\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {\n\n        Subject subject = getSubject(request, response);\n        String[] rolesArray = (String[]) mappedValue;\n\n        if (rolesArray == null || rolesArray.length == 0) {\n            //no roles specified, so nothing to check - allow access.\n            return false;\n        }\n\n        List<String> roles = CollectionUtils.asList(rolesArray);\n        boolean[] hasRoles = subject.hasRoles(roles);\n        for (boolean hasRole : hasRoles) {\n            if (hasRole) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n#### （4）最后就是controller\ncontroller是springMvc的前端控制器，接收什么请求，并且返回对应指定的页面（映射）。\n首先我们先将所以页面的映射写好，\n\nPageController:\n```java\n@Controller\npublic class PageController {\n\n    @RequestMapping({\"/\", \"index\"})\n    public String index() {\n        return \"index\";\n    }\n\n    @RequestMapping(\"about\")\n    public String toAboutPage() {\n        return \"redirect:http://www.ideal-20.cn\";\n    }\n\n    @RequestMapping(\"/toLoginPage\")\n    public String toLoginPage() {\n        return \"views/login\";\n    }\n\n    @RequestMapping(\"/levelA/{name}\")\n    public String toLevelAPage(@PathVariable(\"name\") String name) {\n        return \"views/L-A/\" + name;\n    }\n\n    @RequestMapping(\"/levelB/{name}\")\n    public String toLevelBPage(@PathVariable(\"name\") String name) {\n        return \"views/L-B/\" + name;\n    }\n\n    @RequestMapping(\"/levelC/{name}\")\n    public String toLevelCPage(@PathVariable(\"name\") String name) {\n        return \"views/L-C/\" + name;\n    }\n\n    @RequestMapping(\"/unauthorized\")\n    public String toUnauthorizedPage() {\n        return \"views/unauthorized\";\n    }\n\n    @RequestMapping(\"/success\")\n    public String toSuccessPage() {\n        return \"views/success\";\n    }\n\n}\n\n```\n\nUserController:\n上面那两个映射，只是测试，主要是那个login方法，他可以根据我们前台输入的数据，并创建一个token，如果该token能被认证，即返回成功页面，否则就失败。\n```java\n@Controller\npublic class UserController {\n    @RequestMapping(\"/user/queryAll\")\n    @ResponseBody\n    public String queryAll() {\n        return \"这是 user/queryAll 方法\";\n    }\n\n    @RequestMapping(\"/user/admin/add\")\n    @ResponseBody\n    public String adminAdd() {\n        return \"这是 user/adminAdd 方法\";\n    }\n\n    @RequestMapping(\"/login\")\n    public String login(String username, String password, HttpServletRequest request) {\n        // 由于是根据name参数获取的，我这里封装了一下\n        User user = new User();\n        user.setUsername(username);\n        user.setPassword(password);\n\n        // 创建出一个 Token 内容本质基于前台的用户名和密码（不一定正确）\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n        // 获取 subject 认证主体（这里也就是现在登录的用户）\n        Subject subject = SecurityUtils.getSubject();\n        try{\n            // 认证开始，这里会跳转到自定义的 UserRealm 中\n            subject.login(token);\n            // 可以存储到 session 中\n            request.getSession().setAttribute(\"user\", user);\n            return \"views/success\";\n        }catch(Exception e){\n            // 捕获异常\n            e.printStackTrace();\n            request.getSession().setAttribute(\"user\", user);\n            request.setAttribute(\"errorMsg\", \"兄弟，用户名或密码错误\");\n            return \"views/login\";\n        }\n    }\n}\n```\n\n\n## 8.最终效果：\n首先是http://localhost:8080/index\n\n![QQ截图20201120134737.png](http://ww1.sinaimg.cn/large/006ncldEgy1gkvl9s8sz2j31840eqjxe.jpg)\n\n\n**登录界面：**\n\n![QQ截图20201120134930.png](http://ww1.sinaimg.cn/large/006ncldEgy1gkvlbq3dxaj30zw0izmxj.jpg)\n\n\n表单提交后，就返回值到UserController那个Login方法，认证：\n\n![QQ截图20201120135024.png](http://ww1.sinaimg.cn/large/006ncldEgy1gkvlcnd82yj30e506yq32.jpg)\n\n\n这样我们就登录成功了，并且是superAdmin的权限，可以查看A,B,C\n\n![QQ截图20201120135156.png](http://ww1.sinaimg.cn/large/006ncldEgy1gkvle8g9t0j31620jtwkr.jpg)\n\n而用户张三，只能看见A\n![QQ截图20201120135305.png](http://ww1.sinaimg.cn/large/006ncldEgy1gkvlffinvmj315i0l4wko.jpg)\n\n\n到此结束，本博客借鉴：[博客](https://juejin.cn/post/6850418112173441037#heading-27),需要源码的请查看此博客。","tags":["spring boot","shiro","thymeleaf","ssm"],"categories":["java","ssm"]},{"title":"MySQL基础","url":"/2024/01/06/MySQL基础/","content":"\n# MySQL\n#### SQL语法：\n通用语法：<!--more-->\n1. SQL 语句可以单行或多行书写，以分号结尾。\n2. 可使用空格和缩进来增强语句的可读性。\n3. MySQL 数据库的 SQL 语句不区分大小写。\n4. 三种注释\n   * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) \n   * 多行注释: /* 注释 */\n\n#### SQL分类\n\n1. DDL(Data Definition Language)数据定义语言,用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\n2.  DML(Data Manipulation Language)数据操作语言\n用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\n4. DQL(Data Query Language)数据查询语言\n用来查询数据库中表的记录(数据)。关键字：select, where 等\n1. DCL(Data Control Language)数据控制语言\n用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\n\n\n## DDL:操作数据库、表\n\n\t1. 操作数据库：CRUD\n\t\t1. C(Create):创建\n\t\t\t* 创建数据库：\n\t\t\t\t* create database 数据库名称;\n\t\t\t* 创建数据库，判断不存在，再创建：\n\t\t\t\t* create database if not exists 数据库名称;\n\t\t\t* 创建数据库，并指定字符集\n\t\t\t\t* create database 数据库名称 character set 字符集名;\n\n\t\t\t* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk\n\t\t\t\t* create database if not exists db4 character set gbk;\n\t\t2. R(Retrieve)：查询\n\t\t\t* 查询所有数据库的名称:\n\t\t\t\t* show databases;\n\t\t\t* 查询某个数据库的字符集:查询某个数据库的创建语句\n\t\t\t\t* show create database 数据库名称;\n\t\t3. U(Update):修改\n\t\t\t* 修改数据库的字符集\n\t\t\t\t* alter database 数据库名称 character set 字符集名称;\n\t\t4. D(Delete):删除\n\t\t\t* 删除数据库\n\t\t\t\t* drop database 数据库名称;\n\t\t\t* 判断数据库存在，存在再删除\n\t\t\t\t* drop database if exists 数据库名称;\n\t\t5. 使用数据库\n\t\t\t* 查询当前正在使用的数据库名称\n\t\t\t\t* select database();\n\t\t\t* 使用数据库\n\t\t\t\t* use 数据库名称;\n\n\n\t2. 操作表\n\t\t1. C(Create):创建\n\t\t\t1. 语法：\n\t\t\t\tcreate table 表名(\n\t\t\t\t\t列名1 数据类型1,\n\t\t\t\t\t列名2 数据类型2,\n\t\t\t\t\t....\n\t\t\t\t\t列名n 数据类型n\n\t\t\t\t);\n\t\t\t\t* 注意：最后一列，不需要加逗号（,）\n\t\t\t\t* 数据库类型：\n\t\t\t\t\t1. int：整数类型\n\t\t\t\t\t\t* age int,\n\t\t\t\t\t2. double:小数类型\n\t\t\t\t\t\t* score double(5,2)\n\t\t\t\t\t3. date:日期，只包含年月日，yyyy-MM-dd\n\t\t\t\t\t4. datetime:日期，包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\n\t\t\t\t\t5. timestamp:时间错类型\t包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\t\n\t\t\t\t\t\t* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\n\n\t\t\t\t\t6. varchar：字符串\n\t\t\t\t\t\t* name varchar(20):姓名最大20个字符\n\t\t\t\t\t\t* zhangsan 8个字符  张三 2个字符\n\t\t\t\t\n\n\t\t\t* 创建表\n\t\t\t\tcreate table student(\n\t\t\t\t\tid int,\n\t\t\t\t\tname varchar(32),\n\t\t\t\t\tage int ,\n\t\t\t\t\tscore double(4,1),\n\t\t\t\t\tbirthday date,\n\t\t\t\t\tinsert_time timestamp\n\t\t\t\t);\n\t\t\t* 复制表：\n\t\t\t\t* create table 表名 like 被复制的表名;\t  \t\n\t\t2. R(Retrieve)：查询\n\t\t\t* 查询某个数据库中所有的表名称\n\t\t\t\t* show tables;\n\t\t\t* 查询表结构\n\t\t\t\t* desc 表名;\n\t\t3. U(Update):修改\n\t\t\t1. 修改表名\n\t\t\t\talter table 表名 rename to 新的表名;\n\t\t\t2. 修改表的字符集\n\t\t\t\talter table 表名 character set 字符集名称;\n\t\t\t3. 添加一列\n\t\t\t\talter table 表名 add 列名 数据类型;\n\t\t\t4. 修改列名称 类型\n\t\t\t\talter table 表名 change 列名 新列别 新数据类型;\n\t\t\t\talter table 表名 modify 列名 新数据类型;\n\t\t\t5. 删除列\n\t\t\t\talter table 表名 drop 列名;\n\t\t4. D(Delete):删除\n\t\t\t* drop table 表名;\n\t\t\t* drop table  if exists 表名 ;\n\n## DML：增删改表中数据\n\n\t1. 添加数据：\n\t\t* 语法：\n\t\t\t* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\n\t\t* 注意：\n\t\t\t1. 列名和值要一一对应。\n\t\t\t2. 如果表名后，不定义列名，则默认给所有列添加值\n\t\t\t\tinsert into 表名 values(值1,值2,...值n);\n\t\t\t3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来\n\t2. 删除数据：\n\t\t* 语法：\n\t\t\t* delete from 表名 [where 条件]\n\t\t* 注意：\n\t\t\t1. 如果不加条件，则删除表中所有记录。\n\t\t\t2. 如果要删除所有记录\n\t\t\t\t1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作\n\t\t\t\t2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。\n\t3. 修改数据：\n\t\t* 语法：\n\t\t\t* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];\n\n\t\t* 注意：\n\t\t\t1. 如果不加任何条件，则会将表中所有记录全部修改。\n\n\n\n## DQL：查询表中的记录\n\t* select * from 表名;\n\t\n\t1. 语法：\n\t\tselect\n\t\t\t字段列表\n\t\tfrom\n\t\t\t表名列表\n\t\twhere\n\t\t\t条件列表\n\t\tgroup by\n\t\t\t分组字段\n\t\thaving\n\t\t\t分组之后的条件\n\t\torder by\n\t\t\t排序\n\t\tlimit\n\t\t\t分页限定\n\n\n\t2. 基础查询\n\t\t1. 多个字段的查询\n\t\t\tselect 字段名1，字段名2... from 表名；\n\t\t\t* 注意：\n\t\t\t\t* 如果查询所有字段，则可以使用*来替代字段列表。\n\t\t2. 去除重复：\n\t\t\t* distinct\n\t\t3. 计算列\n\t\t\t* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\n\t\t\t* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null\n\t\t\t\t* 表达式1：哪个字段需要判断是否为null\n\t\t\t\t* 如果该字段为null后的替换值。\n\t\t4. 起别名：\n\t\t\t* as：as也可以省略\n\t\t\t\n\n\t3. 条件查询\n\t\t1. where子句后跟条件\n\t\t2. 运算符\n\t\t\t* > 、< 、<= 、>= 、= 、<>\n\t\t\t* BETWEEN...AND  \n\t\t\t* IN( 集合) \n\t\t\t* LIKE：模糊查询\n\t\t\t\t* 占位符：\n\t\t\t\t\t* _:单个任意字符\n\t\t\t\t\t* %：多个任意字符\n\t\t\t* IS NULL  \n\t\t\t* and  或 &&\n\t\t\t* or  或 || \n\t\t\t* not  或 !\n\t\t\t\n\t\t\t\t-- 查询年龄大于20岁\n\n\t\t\t\tSELECT * FROM student WHERE age > 20;\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE age >= 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄等于20岁\n\t\t\t\tSELECT * FROM student WHERE age = 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄不等于20岁\n\t\t\t\tSELECT * FROM student WHERE age != 20;\n\t\t\t\tSELECT * FROM student WHERE age <> 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄大于等于20 小于等于30\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE age >= 20 &&  age <=30;\n\t\t\t\tSELECT * FROM student WHERE age >= 20 AND  age <=30;\n\t\t\t\tSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n\t\t\t\t\n\t\t\t\t-- 查询年龄22岁，18岁，25岁的信息\n\t\t\t\tSELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\n\t\t\t\tSELECT * FROM student WHERE age IN (22,18,25);\n\t\t\t\t\n\t\t\t\t-- 查询英语成绩为null\n\t\t\t\tSELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE english IS NULL;\n\t\t\t\t\n\t\t\t\t-- 查询英语成绩不为null\n\t\t\t\tSELECT * FROM student WHERE english  IS NOT NULL;\n\t\n\n\n\t\t\t\t-- 查询姓马的有哪些？ like\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE '马%';\n\t\t\t\t-- 查询姓名第二个字是化的人\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE \"_化%\";\n\t\t\t\t\n\t\t\t\t-- 查询姓名是3个字的人\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE '___';\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t-- 查询姓名中包含德的人\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE '%德%';\n\n\n\n\t","tags":["MySql"],"categories":["SQL"]},{"title":"markdown基础语法","url":"/2024/01/06/markdown基础语法/","content":"\n最近在养成写博客的习惯，现在很多的网站都支持Markdown，但是老忘记语法，所以记录一下基础语法。\n\n先说下我感觉的Markdown的优点：\n1. 只用写一篇博客，就能复制粘贴到多个社区，大大**节省了时间**。\n   以下都支持Markdown，是不是感觉很划算，😁！\n   <!--more-->\n    *   Github\n    *   码云\n    *   Cmd-Markdown\n    *   知乎\n    *   博客园\n    *   CSDN\n    *   简书\n    *   segmentfault\n    *   有道云笔记\n    *   Ghost\n    *   Typecho\n    *   印象笔记\n2. 只用注意文章内容，不用去多想**排版**。\n \n\n> 更多高阶语法请查看[菜鸟教程](https://www.runoob.com/markdown/md-advance.html)\n\n下文**每个一级标题**代表一个语法：\n**可以通过旁边的目录，快速定位某个语法！**\n\n\n\n# 1.标题  \n\n# 一级标题是:`#空格 `\n## 二级标题是:`##空格 `\n### 三级标题是: `###空格 `\n#### 四级标题是: `####空格 `\n<br><br>\n\n# 2.段落\n这是一个段落\n\n这是第二个段落，进行了换行\n\n**格式：**\n```\n换行直接就回车键，也可以通过HTML语法：<br><br>\n```\n<br><br>\n\n# 3.字体\n*斜体是一个* \\*\n**粗体两个** \\**\n***斜粗体*** \\***\n<br><br><br>\n\n# 4.分割线\n\n***\n***\n***\n**分割线是\\*****\n<br><br><br>\n\n# 5.删除线\n~~这条文字被删除~~~~\n**格式**\n```\n~~删除线这样写~~\n```\n<br><br><br>\n\n# 6.下划线\n<u>下划线</u>\n```\n下划线是<u></u>\n```\n<br>\n\n# 7.脚注\n创建脚注格式类似这样 [^1]。\n[^]:    www.baidu.com\n\n**格式**\n```\n创建脚注格式类似这样 [^]。\n[^1]: www.baidu.com\n```\n<br><br>\n\n# 8.列表\n####  (1)无序列表\n* 无序列表是：  *空格文字\n* 无序列表是：  *空格文字\n* 无序列表是：  *空格文字  \n<br>\n\n#### (2)有序列表\n1. 有序列表格式是：  数字空格文字 \n1. 有序列表格式是：  数字空格文字\n1. 有序列表格式是：  数字空格文字\n1. 有序列表格式是：  数字空格文字\n\n**前面的数字可以不按顺序写，markdown会为你自动排序，即使你全部都写成<font color=red>1空格文字</font>**\n<br>\n#### (3)列表嵌套\n1. 外层1\n   * 内层1\n   * 内层2\n   * 内层3\n2. 外层2\n    1. 内层1\n    1. 内层1\n    1. 内层1\n\n**语法和上面一样**\n<br><br>\n\n# 9.引用\n> 引用自陈全蛋的博客\n>> 引用自陈全蛋的博客\n>>> 引用自陈全蛋的博客\n\n引用也可以循环嵌套\n\n**格式：**\n```\n> 引用自陈全蛋的博客\n>> 引用自陈全蛋的博客\n>>> 引用自陈全蛋的博客\n```\n<br><br>\n\n# 10.代码\n#### (1)行内代码\n我们需要进行输出行内代码： `System.out.println()`\n\n**格式：**\n```\n`System.out.println()`\n```\n\n#### (1)代码块\n你也可以用 ```包裹一段代码，并指定一种语言（也可以不指定）：\n\n```javascript\n$(document).ready(function () {\n    alert('RUNOOB');\n});\n```\n**格式：**\n![QQ截图20200725231954.png](https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzAwNm5jbGRFZ3kxZ2gzbXBqamI1NWozMHQxMDRlM3llLmpwZw?x-oss-process=image/format,png)\n<br><br>\n\n# 11.链接\n\n[这是一个github的链接](https://github.com/)\n\n**格式：**\n![QQ截图20200726133131.png](https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzAwNm5jbGRFZ3kxZ2g0YmJ4eGZxNmozMGN5MDIxZGZvLmpwZw?x-oss-process=image/format,png)\n<br><br>\n\n# 12.图片\n图片使用微博图床：\n在浏览器中安装一个插件新浪微博插件，把你想要上传的图片直接拖到插件里面，会生成Http连接，在把链接复制到markdown编辑器中即可。\n\n**格式：**\n![QQ截图20200726133926.png](https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzAwNm5jbGRFZ3kxZ2g0YmpyNngzb2ozMGZ0MDF1d2VmLmpwZw?x-oss-process=image/format,png)\n\n<br><br>\n\n# 13.表格\n|  表头 |表头   |\n|---    |---    |\n|单元格|单元格|\n|单元格|单元格|\n|单元格|单元格|\n\n**格式：**\n![QQ截图20200726134310.png](https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzAwNm5jbGRFZ3kxZ2g0Ym40anVxa2ozMDdvMDQ5bXd4LmpwZw?x-oss-process=image/format,png)\n\n```","tags":["Markdown"],"categories":["博客"]},{"title":"JDBC笔记","url":"/2024/01/06/JDBC笔记/","content":"\n# 1.使用步骤：\n1. 导包\n1. 加载驱动类class.forName(....)  <!--more-->\n2. DriverManager获取sql对象\n3. 写sql语句\n4. Statement与prepareStatement不一样的执行sql语句，前者是直接sql对象 . 执行语句，而后者是预处理，即在创建sql对象时，就用sql语句，最后在用对象执行操作。\n\n# 2.JDBCUtils工具类：\n就是把使用步骤的共性，提出来，放在一个类中，这样以后就能直接调用创建sql对象的方法就行了。\n值得一提的是，如果我们使用配置文件，扩展性更好，在使用其他数据库时，我们只需要更改配置文件properties。获取配置文件可以使用properties对象。获取jar包的绝对路径可以使用classLoader类加载器。这样我们就不用自己添加路径了。\n```java\npublic class JDBCUtils {\n        private static String url;\n        private static String user;\n        private static String password;\n        private static String driver;\n        /**\n         * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块\n         */\n        static{\n            //读取资源文件，获取值。\n    \n            try {\n                //1. 创建Properties集合类。\n                Properties pro = new Properties();\n    \n                //获取src路径下的文件的方式--->ClassLoader 类加载器\n                ClassLoader classLoader = JDBCUtils.class.getClassLoader();\n                URL res  = classLoader.getResource(\"jdbc.properties\");\n                String path = res.getPath();\n                \n                //2. 加载文件\n                pro.load(new FileReader(path));\n    \n                //3. 获取数据，赋值\n                url = pro.getProperty(\"url\");\n                user = pro.getProperty(\"user\");\n                password = pro.getProperty(\"password\");\n                driver = pro.getProperty(\"driver\");\n                //4. 注册驱动\n                Class.forName(driver);\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (ClassNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n    \n    \n        /**\n         * 获取连接\n         * @return 连接对象\n         */\n        public static Connection getConnection() throws SQLException {\n    \n            return DriverManager.getConnection(url, user, password);\n        }\n    \n        /**\n         * 释放资源\n         * @param stmt\n         * @param conn\n         */\n        public static void close(Statement stmt,Connection conn){\n            if( stmt != null){\n                try {\n                    stmt.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n    \n            if( conn != null){\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    \n    \n        /**\n         * 释放资源\n         * @param stmt\n         * @param conn\n         */\n        public static void close(ResultSet rs,Statement stmt, Connection conn){\n            if( rs != null){\n                try {\n                    rs.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n    \n            if( stmt != null){\n                try {\n                    stmt.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n    \n            if( conn != null){\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    \n    }\n\n```\n\n\n# 3.DBC控制事务：\n在执行sql语句时，如果程序执行过程中，发生了异常。比如有两个sql语句，一个是转账操作，一个人存转的这笔钱，如果第一个操作结束后发生了异常。那么这笔钱就会不翼而飞，所以为了避免这样的情况，可以使用事务。\n\n(1)具体操作\n1. 开启事务：setAutoCommit( boolean autoCommit ) ：调用该方法设置参数为false，即开启事务。\n2. 提交事务：commit( )当所有sql都执行完提交事务。\n3. 回滚事务：rollback( ) 在catch中回滚事务。\n\n```java\npublic static void main(String[] args) {\n    PreparedStatement pstmt1 = null;\n    PreparedStatement pstmt2 = null;\n    Connection con = null;\n\n\n    try {\n        con = JDBCUtils.getConnection();\n        //开启事务\n        con.setAutoCommit(false);\n        //2.1 张三 - 500\n        String sql1 = \"update account set balance = balance - ? where id = ?\";\n        //2.2 李四 + 500\n        String sql2 = \"update account set balance = balance + ? where id = ?\";\n\n\n        pstmt1 = con.prepareStatement(sql1);\n        pstmt2 = con.prepareStatement(sql2);\n\n\n        //4. 设置参数,sql语句里的问号\n        pstmt1.setDouble(1,500);//填第一个数据\n        pstmt1.setInt(2,1);//填第二个数据\n\n\n        pstmt2.setDouble(1,500);\n        pstmt2.setInt(2,2);\n        //5.执行sql\n        pstmt1.executeUpdate();\n        // 手动制造异常\n        int i = 3/0;\n\n\n        pstmt2.executeUpdate();\n        //提交事务\n        con.commit();\n    } catch (SQLException e) {\n        e.printStackTrace();\n    } catch (Exception e){\n        try {\n            con.rollback();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n    } finally{\n       JDBCUtils.close(con,pstmt1);\n       JDBCUtils.close(con,pstmt2);\n    }\n}\n\n```\n\n\n# 4.JDBC连接池\n连接池，就是先创建好一些连接对象，要用的的时候，直接使用，提高了效率，用完之后，归还给连接池，以便其他的使用。\n\n1. **c3p0连接池：**\n  步骤：\n2. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，还需要导入数据库驱动jar包\n\t\n3. 定义配置文件：\n\t* 名称： c3p0.properties 或者 c3p0-config.xml。\n\t* 路径：直接将文件放在src目录下即可。\n\n3. 创建核心对象 数据库连接池对象 ComboPooledDataSource\n4. 获取连接： getConnection\n代码：\n```java\n //1.创建数据库连接池对象\n      DataSource ds  = new ComboPooledDataSource();\n      //2. 获取连接对象\n      Connection conn = ds.getConnection();\n```\n\n\n5. **druid：**\n这个是阿里的，性能更好，效率更高。\n步骤：\n   1. 导入jar包 druid-1.0.9.jar\n   2. 定义配置文件：\n      *  是properties形式的\n      * 可以叫任意名称，可以放在任意目录下\n   3. 加载配置文件。Properties\n   4. 获取数据库连接池对象：通过工厂类来获取  DruidDataSourceFactory\n   5. 获取连接：getConnection\n代码：\n```java\n    //3.加载配置文件\nProperties pro = new Properties();\nInputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\");\npro.load(is);\n//4.获取连接池对象\nDataSource ds = DruidDataSourceFactory.createDataSource(pro);\n//5.获取连接\nConnection conn = ds.getConnection();\n```\n\n由于代码还是冗长，重复率高，所以可以自定义个工具类：\n```java\npublic class JDBCUtils {\n\n\t\t\t    //1.定义成员变量 DataSource\n\t\t\t    private static DataSource ds ;\n\t\t\t\n\t\t\t    static{\n\t\t\t        try {\n\t\t\t            //1.加载配置文件\n\t\t\t            Properties pro = new Properties();\n\t\t\t            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"));\n\t\t\t            //2.获取DataSource\n\t\t\t            ds = DruidDataSourceFactory.createDataSource(pro);\n\t\t\t        } catch (IOException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        } catch (Exception e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t    }\n\t\t\t\n\t\t\t    /**\n\t\t\t     * 获取连接\n\t\t\t     */\n\t\t\t    public static Connection getConnection() throws SQLException {\n\t\t\t        return ds.getConnection();\n\t\t\t    }\n\t\t\t\n\t\t\t    /**\n\t\t\t     * 释放资源\n\t\t\t     */\n\t\t\t    public static void close(Statement stmt,Connection conn){\n\t\t\t       /* if(stmt != null){\n\t\t\t            try {\n\t\t\t                stmt.close();\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t\n\t\t\t        if(conn != null){\n\t\t\t            try {\n\t\t\t                conn.close();//归还连接\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }*/\n\t\t\t\n\t\t\t       close(null,stmt,conn);\n\t\t\t    }\n\t\t\t\n\t\t\t\n\t\t\t    public static void close(ResultSet rs , Statement stmt, Connection conn){\n\t\t\t\n\t\t\t\n\t\t\t        if(rs != null){\n\t\t\t            try {\n\t\t\t                rs.close();\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t\n\t\t\t\n\t\t\t        if(stmt != null){\n\t\t\t            try {\n\t\t\t                stmt.close();\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t\n\t\t\t        if(conn != null){\n\t\t\t            try {\n\t\t\t                conn.close();//归还连接\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t\n\t\t\t    /**\n\t\t\t     * 获取连接池方法\n\t\t\t     */\n\t\t\t\n\t\t\t    public static DataSource getDataSource(){\n\t\t\t        return  ds;\n\t\t\t    }\n\t\t\t\n\t\t\t}\n```\n\n3. **Spring JDBC**\n* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发\n\t* 步骤：\n\t\t1. 导入jar包\n\t\t2. 创建JdbcTemplate对象。依赖于数据源DataSource\n\t\t\t* JdbcTemplate template = new JdbcTemplate(ds);\n\n\t\t3. 调用JdbcTemplate的方法来完成CRUD的操作\n\t\t\t* update():执行DML语句。增、删、改语句\n\t\t\t* queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合\n\t\t\t\t* 注意：这个方法查询的结果集长度只能是1\n\t\t\t* queryForList():查询结果将结果集封装为list集合\n\t\t\t\t* 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中\n\t\t\t* query():查询结果，将结果封装为JavaBean对象\n\t\t\t\t* query的参数：RowMapper\n\t\t\t\t\t* 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装\n\t\t\t\t\t* new BeanPropertyRowMapper<类型>(类型.class)\n\t\t\t* queryForObject：查询结果，将结果封装为对象\n\t\t\t\t* 一般用于聚合函数的查询\n\n```java\n //2. 定义sql\n \n//1. 获取JDBCTemplate对象\nprivate JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());\nString sql = \"update emp set salary = 10000 where id = 1001\";\n//3. 执行sql\nint count = template.update(sql);\nSystem.out.println(count);\n```\n\n这大大简化了我们curd的代码量。","tags":["JDBC","java"],"categories":["java"]},{"title":"java验证输入是否为三阶幻方","url":"/2024/01/06/java验证输入是否为三阶幻方/","content":"## 问题描述：\n\n小明最近在教邻居家的小朋友小学奥数，而最近正好讲述到了三阶幻方这个部分<!--more-->，三阶幻方指的是将1~9不重复的填入一个3*3的矩阵当中，使得每一行、每一列和每一条对角线的和都是相同的。\n三阶幻方又被称作九宫格，在小学奥数里有一句非常有名的口诀：“二四为肩，六八为足，左三右七，戴九履一，五居其中”，通过这样的一句口诀就能够非常完美的构造出一个九宫格来。\n　　4 9 2\n　　3 5 7\n　　8 1 6\n\n有意思的是，所有的三阶幻方，都可以通过这样 **一个九宫格进行若干镜像和旋转操作之后得到** 。现在小明准备将一个三阶幻方（不一定是上图中的那个）中的一些数抹掉，交给邻居家的小朋友来进行还原，并且希望她能够判断出究竟是不是只有一个解。\n而你呢，也被小明交付了同样的任务，但是不同的是，你需要写一个程序~\n输入格式\n输入仅包含单组测试数据。\n每组测试数据为一个3*3的矩阵，其中为0的部分表示被小明抹去的部分。\n对于100%的数据，满足给出的矩阵至少能还原出一组可行的三阶幻方。\n输出格式\n如果仅能还原出一组可行的三阶幻方，则将其输出，否则输出“Too Many”（不包含引号）。\n样例输入\n0 7 2\n0 5 0\n0 3 0\n样例输出\n6 7 2\n1 5 9\n8 3 4\n数据规模和约定\n峰值内存消耗（含虚拟机） < 256M\nCPU消耗 < 1000ms\n## 思路：\n首先通过题目，可以知道其实三阶幻方，只有一种解，其他的全部是通过旋转，镜像得到的，只能旋转4个方法，在镜像，一共八个。暴力破解就完事了。\n但是怎么个暴力呢，通过观察知道，中间必定为5，而且只需要两个数字，我们就能唯一确定一个三阶幻方了，所以排除0和5，获得前两个数字的索引，我们就能去遍历8种情况，通过这两个索引判断，只要是在对应的位置上相等，既是我们要找的三阶幻方。\n\n## 代码实现：\n\n```java\npublic class Test4 {\n    public static void main(String[] args) {\n        method1(\"400950000\");\n    }\n    //输入一个矩阵看他是否存在三阶幻方，甚至有多个\n    private static void method1(String matrix) {\n        long start = System.currentTimeMillis();\n        char[] chars = matrix.toCharArray();\n        int i = 0;\n        //保存2个索引，除5之外\n        int[] index = new int[2];\n        int j = 0;\n        //保存所有情况\n        ArrayList<String> arr = new ArrayList<>();\n        //遍历字符数组，获取除5外，两个值得索引\n        for (; i < chars.length; i++) {\n            char a = chars[i];\n            if (a!= '0' && a!='5'){\n                if (j < 2){\n                    index[j] = i;\n                    j++;\n                }\n            }\n            //遍历每种可能，看是否相应位置为该值\n            arr.add(\"492357816\");\n            arr.add(\"294753618\");\n            arr.add(\"834159672\");\n            arr.add(\"438951276\");\n            arr.add(\"618753294\");\n            arr.add(\"276951438\");\n            arr.add(\"816357492\");\n            arr.add(\"672159834\");\n        }\n        //保存到int[]\n        System.out.println(Arrays.toString(index));\n        for (String s : arr) {\n            //将已知的字符数组转换成字符集\n            char[] tar = s.toCharArray();\n            if (tar[index[0]] == chars[index[0]] && tar[index[1]] == chars[index[1]]){\n                System.out.println(s);\n                break;\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(end-start+ \" 毫秒\");\n    }\n}\n\n```\n\n","tags":["枚举法"],"categories":["算法"]},{"title":"IO流为什么要边读编写","url":"/2024/01/06/IO流为什么要边读编写/","content":"\n\n\n本博客的内容包含了字节流，缓冲数组的概念。主要是研究<font color=red>**为什么write(bytes)要放在read(bytes)的while循环里，及为啥要一边读，一遍写，而不是读完了（输入），再写（输出）。**</font>\n<!--more-->\n今天学习到TCP时,使用Client向Server传入数据，其实这就是一种变相的<font color=red>复制文件</font>，只是输出的目的地是服务器罢了。\n\n下面是服务端的代码，没有任何问题。\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //1.创建serverSocket对象，传入端口号\n        ServerSocket serverSocket = new ServerSocket(8888);\n        //2.用serverSocket接收，客户端请求的socket对象\n        Socket socket = serverSocket.accept();\n        //3.使用socket对象来获取网络输入流对象，用来读取客户端输出的数据\n        InputStream is = socket.getInputStream();\n        //如果文件夹不存在，则创建一个\n        File file = new File(\"F:\\\\FileUpdate\");\n        if (!file.exists()){\n            file.mkdirs();\n        }\n        //4.创建本地输出流对象\n        FileOutputStream fos = new FileOutputStream(file+\"\\\\dog.jpg\");\n        //保存客户端输出的数据\n        byte[] bytes = new byte[1024];\n        int len = 0 ;\n        //网络输入流，读取客户端发送的数据，并复制到本地输出流对象指定的目的地\n        while((len = is.read(bytes))!=-1){\n            System.out.println(\"保存中\");\n            fos.write(bytes);\n        }\n        System.out.println(\"wocap\");\n        //5.利用socket对象，获取网络输出流对象\n        OutputStream os = socket.getOutputStream();\n        //6.向客户端发送数据\n        if (bytes!=null){\n            os.write(\"你好，你发送的数据已经保存成功\".getBytes());\n        }else {\n            os.write(\"操作异常，请再次传输数据\".getBytes());\n        }\n        //7.释放资源\n        fos.close();\n        serverSocket.close();\n        socket.close();\n    }\n}\n\n```\n在复制文件时，发生了点小插曲，就是服务器下载不下来文件，所以我就调试，在服务器程序中的<font color=red>读取文件的while循环</font>里打下了断点：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200724194249725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n结果，在第二次循环时，停下了，紧接着去看照片是否复制好了，的确是由文件，因为执行了一次循环，但是为什么第二次就停止了呢？并且并没有向下执行，而是<font color=red>阻塞在了while循环第一句</font>，我想应该是is.read(bytes)的问题，于是查看API,以下是原文：\n>public int read(byte[] b)\n         throws IOException从输入流中读取一定数量的字节，并将其<font color=red>**存储在缓冲区数组 b** </font>中。以整数形式返回实际读取的字节数。<font color=red>在输入数据可用、检测到文件末尾或者抛出异常前， **此方法一直阻塞。**</font>\n如果 b 的长度为 0，则不读取任何字节并返回 0；否则，尝试读取至少一个字节。<font color=red>如果因为流位于文件末尾而没有可用的字节，则返回值 -1</font>；否则，至少读取一个字节并将其存储在 b 中。 \n\n><font color=red>将读取的第一个字节存储在元素 b[0] 中，下一个存储在 b[1] 中</font>，依次类推。读取的字节数最多等于 b 的长度。设 k 为实际读取的字节数；这些字节将存储在 b[0] 到 b[k-1] 的元素中，<font color=red>不影响 b[k] 到 b[b.length-1] 的元素</font>。 \n\n通过API原文我们可以发现，阻塞在while循环第一句的原因：是没有检测到文件末尾及-1,所以程序一直被阻塞了，而没有向下执行。\n\n那么问题来了，为啥没有我们的文件没有数据了呢，原因只有一个，那就是客户端没有把文件的字节全部输出，所以回头看,发现我们的Client里出现了错误：\n\n```java\nwhile((len = fis.read(bytes))!=-1){\n            System.out.println(\"传输中\");\n        }\n        os.write(bytes);\n```\n对，没错就是今天标题，<font color=red>使用字节流复制文件时，为什么write(bytes)要放在read(bytes)的while循环里</font>,通过API的介绍我们知道了我们形参bytes是一个缓冲数组，所谓缓冲数组，就是暂时放进，但是在<font color=red>**再次调用会重新赋值**</font>。\n\n于是为了一探究竟我就去看了源码，但是发现他的底层是一个native声明的函数，看不见，native声明的函数是其他语言编写的，如C++，但是我想到了一个方法，怎么研究<font color=red>缓冲数组是否会被重新赋值</font>.\n\n就是通过，<font color=red>每次输出缓冲数组的第一个字节</font>：代码如下：\n\n```java\npublic class copyDemo1 {\n    public static void main(String[] args) throws IOException {\n        FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\asusc\\\\Pictures\\\\Saved Pictures\\\\dog.jpg\");\n        FileOutputStream fos = new FileOutputStream(\"F.jpg\");\n        byte[] bytes = new byte[1024];\n        int readLen= 0;\n        int i =0;\n        while((readLen= fis.read(bytes))!=-1){\n           System.out.println(\"缓冲数组第一个字节\"+bytes[0]);\n        }\n        fos.write(bytes,0,readLen);\n\n        fos.close();\n        fis.close();\n    }\n}\n\n```\n输出结果：\n\n```handlebars\n缓冲数组第一个字节-1\n缓冲数组第一个字节-91\n缓冲数组第一个字节7\n缓冲数组第一个字节117\n缓冲数组第一个字节-86\n缓冲数组第一个字节-55\n缓冲数组第一个字节-110\n\n```\n\n显而易见，我们的思路是对的，<font color=red>**缓冲数组，的确会在每次被调用时，被重新赋值**</font>。\n\n所以也就说明了为啥<font color=red>write(bytes)要放在read(bytes)的while循环里，及为啥要一边读，一遍写。</font>因为缓冲数组，会被重新赋值，如果把write()放在read()方法的while循环外面，会造成数组越界的异常。上面的例子也会抛出异常，因为write()写数据时，写完那1024个字节的数组，就没了,缓冲数组为空。\n\n\n\n下面是**客户端向服务器传入数据**的正确代码：\n\n<font color=red>**客户端**</font>\n\n```java\npackage Net.FileUpdate;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //1.创建本地文件输入流，读取本地的文件\n        FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\asusc\\\\Pictures\\\\Saved Pictures\\\\dog.jpg\");\n        //2.创建socket对象，传入ip和端口号\n        Socket socket = new Socket(\"localhost\",8888);\n        //装被读取文件的字节数组\n        byte[] bytes = new byte[1024];\n        int len = 0;\n        \n        //3.获取网络输出流的对象，向服务端写入数据\n        OutputStream os = socket.getOutputStream();\n\n        while((len = fis.read(bytes))!=-1){\n            System.out.println(\"传输中\");\n            os.write(bytes);\n        }\n\n        //4.获取网络输入流的对象，用于读取服务器输入的数据\n        InputStream is = socket.getInputStream();\n        byte[] bytes1 = new byte[1024];\n        int len1 = is.read(bytes);\n        System.out.println(new String(bytes1,0,len));\n        //5.释放资源\n        fis.close();\n        socket.close();\n    }\n}\n\n```\n\n<font color=red>**服务端**</font>\n\n```java\npackage Net.FileUpdate;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //1.创建serverSocket对象，传入端口号\n        ServerSocket serverSocket = new ServerSocket(8888);\n        //2.用serverSocket接收，客户端请求的socket对象\n        Socket socket = serverSocket.accept();\n        //3.使用socket对象来获取网络输入流对象，用来读取客户端输出的数据\n        InputStream is = socket.getInputStream();\n        //如果文件夹不存在，则创建一个\n        File file = new File(\"F:\\\\FileUpdate\");\n        if (!file.exists()){\n            file.mkdirs();\n        }\n        //4.创建本地输出流对象\n        FileOutputStream fos = new FileOutputStream(file+\"\\\\dog.jpg\");\n        //保存客户端输出的数据\n        byte[] bytes = new byte[1024];\n        int len = 0 ;\n        //网络输入流，读取客户端发送的数据，并复制到本地输出流对象指定的目的地\n        while((len = is.read(bytes))!=-1){\n            System.out.println(\"保存中\");\n            fos.write(bytes);\n        }\n        System.out.println(\"wocap\");\n        //5.利用socket对象，获取网络输出流对象\n        OutputStream os = socket.getOutputStream();\n        //6.向客户端发送数据\n        if (bytes!=null){\n            os.write(\"你好，你发送的数据已经保存成功\".getBytes());\n        }else {\n            os.write(\"操作异常，请再次传输数据\".getBytes());\n        }\n        //7.释放资源\n        fos.close();\n        serverSocket.close();\n        socket.close();\n    }\n}\n\n```\n**好了，博客到现在也就写完了，希望能帮助到遇到此问题的你。**","tags":["IO"],"categories":["Java"]},{"title":"本站第一篇博客","url":"/2024/01/06/hello-world/","content":"#coding\n\n","categories":["杂记"]},{"title":"用Hexo+gitHub Pages生成一个静态网页","url":"/2020/07/22/用Hexo-gitHub-Pages生成一个静态网页/","content":"## 如何用Hexo+Github Pages快速搭建自己的博客\n**保姆级教程**\n本文章快速搭建博客，有一个前提，那就是对git有所了解，如果你对git的使用即原理很熟悉的话，那么这个博客搭建就会很快，不超过一个小时。当然你下载资源很慢，就当我没说，嘻嘻。当然如果你不了解，也没关系，凡事都是从0开始的，我也会在文中讲解的，废话少说，开始！\n<!--more-->\n\n# 温馨提示\n\n1.首先要知道搭建网站你的目的是什么，有动力，才有坚持下去的勇气，也才会有拨开云雾见太阳的高兴(博客搭建好的时候)。\n\n2.资源下载慢是很大的问题，下面会解答。\n\n3.如果你github网站访问速度巨慢，建议谷歌或者百度，毕竟面向谷歌编程嘛,哈哈哈。\n\n# 文章导读\n1.介绍要下载的东西\n2.安装\n3.搭建\n4.原理解释（之所以放在最后，是给自己总结，明白其原理，回过头才会理解更深,当然后面美化博客，也需要知道大概原理。）\n\n\n# 1.介绍工具，安装的东西\n如果不耐烦，可以直接跳过到安装步骤。\n1.git：按我自己的理解，git可以再我们的电脑上创建一个本地仓库（在这就是我们的博客仓库），然后把我们的网页部署到github上的github Pages上。\n2.node.js:不安装这玩意，就没法玩。因为他要安装Hexo。\n3.Hexo：这个东西可以把我们本地的Markdown文件，后缀.md的文件，处理，渲染，然后变成静态网页，也就是我们的博客。\n**所有看官们知道了吧，慢慢安装吧，不安装好，博客就凉凉了。**\n\n\n# 2.安装工具\n\n## （1）安装Node.js\n\n这个玩意推荐大家去[官网下载](https://nodejs.org/en/download/)，网不好建议下载个火狐浏览器。进入官网，直接选自己是多少位的就行。不知道的到我的电脑去看。我选的windows 64-bit。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020072216425447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n\n## （2）安装git\n\n这个也是[Git官网](https://git-scm.com/download/win)下载，跟上面一样，选择对应的版本下载即可。\n下载好了就安装，安装一直next就行，然后cmd里git version，有版本号就成功了。然后去桌面有键就有下面两个git了。上面那个是图形化管理工具，由于做的比较丑，我们还是选用下面的命令行来操作。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722165345367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n## （3）安装主角Hexo\n\n由于Hexo这玩意是托管在国外的，所以啊，下载会巨慢，所以我们就用国内的淘宝镜像。在cmd中输入以下：\n\n```java\n npm config set registry https://registry.npm.taobao.org\n npm config get registry//**这个是用来检查换成功没**\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722170142375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n\n安装Hexo\n\n```java\n npm install hexo-cli -g\n```\n\n安装hexo的一个相当于命令的东西吧。后面原理会讲。\n\n```java\nnpm install hexo-deployer-git --save\n```\n\n第二句是安装hexo部署到git page的deployer\n\n换好镜像，安装好Hexo，搭建博客的前戏就完了，可以喝杯咖啡，起来走走，劳逸结合嘛。\n\n\n# 3.搭建博客\n这个部分，如果网速好，很快就完事了，网速不好，就静静等吧。\n## （1）初始化博客\n首先自己选个地方，创建一个文件夹，来装我们博客的主体。\n比如F:\\Projects\\blog，文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722173038128.png)\n这里是最耗时间的了，因为主题，资源比较多，下载会很慢，不过，只要是网速问题，我们都能解决，就是通过换淘宝镜像，提高速度。其他的不懂谷歌呀，哈哈。\n初始化好之后，一个崭新的博客出现在了我们眼前。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722173425166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n这时候，再bush中输入\n\n```java\nhexo s\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722173741722.png)\n\n直接网页搜索localhost:4000，你的博客雏形就出来了。这TM才叫功夫不负有心人。\n当然这只是你本地仓库的博客，我们写博客不就是为了装B吗，不让别人看见，那能叫装B吗？下贱，哈哈哈！开玩笑，写博客肯定是提升自己呀，怎么扯到装B上了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722173644608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n## （2）github的使用\n**敲黑板！！！重点来了！！！**\n部署博客到GIthub - Pages，文章开头不是说了吗，如果你了解git那么，这部分，你可以略过，小白们还是来学下。\n\n首先，注册个github账号吧，总不可能，用别人东西，还不给别人增加流量吧，拒绝白嫖，嘻嘻嘻，**搭建好点赞你懂得**！！！！\n\n\n进入正题，其实不要把github想的很难，主要是英文把你难着了吧，哈哈哈，如果英语差可以谷歌浏览器翻译。\n\ngithub其实就是个托管代码的，我们在这上面建库，然后把代码push上来，当然我们的博客不用push上来，后面讲解原理。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722175701764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n## （3）配置SSH钥匙：\nSSH是个协议，就像HTTPS一样，保证安全的。\n我们要把项目托管上去，github需要知道一把钥匙，这是公钥，我们自己有一把钥匙，叫私钥。\n下面配置：\n**1.创建钥匙：**\n\n```java\n $ ssh-keygen -t rsa -C \"your_email@example.com\"\n#这将按照你提供的邮箱地址，创建一对密钥\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]\n```\n\n直接回车\n\n```java\nEnter passphrase (empty for no passphrase): [Type a passphrase]\nEnter same passphrase again: [Type passphrase again]\n```\n\n```java\nYour identification has been saved in /c/Users/you/.ssh/id_rsa.\nYour public key has been saved in /c/Users/you/.ssh/id_rsa.pub.\nThe key fingerprint is:\n01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com\n```\n\n然后钥匙的位置在用户文件下，叫做  **.ssh**,有个后缀是pub的，这个就是公钥，私钥是另一把，把公钥的内容复制下来，到github，点你的头像，有个setting，设置里去配置公钥。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722181108821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n好了配置好公钥了，下面检查一下\n\n```java\n $ ssh -T git@github.com\n```\n\n```java\nThe authenticity of host 'github.com (207.97.227.239)' can't be established.\nRSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nAre you sure you want to continue connecting (yes/no)?\n```\n输入yes就好了，下面就要设置用户信息了\n\n```java\n$ git config --global user.name \"github名字\"//用户名\n$ git config --global user.email  \"github注册的邮箱\"//填写自己的邮箱\n```\n\n下面点击的你新建的仓库，有个：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200722181722301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n复制你的项目地址，到Hexo的配置文件里：就是\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020072218191032.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjUwOTcxNA==,size_16,color_FFFFFF,t_70)\n找到deploy（部署），开始只有个type的，加上我写的，只用改repository就行了，branch不用改：\n\n```java\ndeploy:\n  type: git\n  repository: git@github.com:chenQD123/chenQD-blog.git\n  branch: master\n```\n**记住这有个坑，** 就是冒号后面有个空格，这是规定，如果没写空格，后面会部署失败，这就像python一样。\n然后就是美汁汁的部署你的博客到github上。\n\n```java\n在Hexo里，\nhexo generate -deploy\n生成+部署\n```\n如果报错：说明最开始让你安装的deploy没成功，所以在安装一次就行了，他也有提示（会让你安装），如下：\n\n```java\nERROR Deployer not found: git\n```\n只需要安装好即可\n```java\nnpm install hexo-deployer-git --save\n```\n\n## （4）部署博客\n好了，结束了，看到这里，你的博客就部署完成了，这时候你的博客，别人就能看见了，只需要在任何一个浏览器输入：\n你的项目名，比如我就是：\n[https://chenqd123.github.io/](https://chenqd123.github.io/)，这也是github给我们的公开地址，不如说是github Pages给的。就是github pages帮我们托管的博客。\n## （5）美化博客\n如果想使自己的博客好看点可以换主题：\n[Hexo官网主题](https://hexo.io/themes/)\n建议换个，使用者多点的主题，这种的说明文档写的比较好，你开荒也会容易点。\n\n# 4.实现原理\n首先来介绍为Hexo：\nHexo是Node.js在github开源的快速开发博客的一个框架。\n那么Hexo究竟怎么帮助我们实现的呢，这里说一下大概原理，我们开始安装Hexo，是通过\n\n```java\nnpm install hexo-cli -g\n```\n安装好之后，我们通过**hexo+命令**这样的方式来操作Hexo的一些插件，就比如：hexo server、hexo generate。\n当执行hexo server时，Hexo的Markdown文档会进行两次渲染，变成我们的博客。\n1.第一次是遍历我们的根目录下的source文件，就是我们博客的页面，他会输出一些article对象，就是我们每个页面等。\n2.hexo generate第二次渲染会遍历我们themes下的文件，这个文件下的内容，是我们美化要修改的地方，他会输出根目录下的public文件夹。\n这个public是我们要托管到github上的博客，当我们hexo deploy完成，就会把我们的博客push，部署到github上，每个github账号都会有一个站点，并且有无限的项目站点。而github pages 就是来托管我们的页面的，通过这个github pages给我们的域名来访问我们的博客，我们每次修改博客时，也只是提交的public文件，hexo generate产生、hexo deploy部署的页面。\n\n# 结语\n写到这了。\n文章到这里就结束了，第一次写这么长的博客，有错请纠正！如果对你有帮助，**点赞点赞**，码了这么多的字，没有功劳也有苦恼呀，呜呜呜（撕心裂肺）。\n\n\n","tags":["Hexo","github","git","Github Pages"],"categories":["博客"]}]