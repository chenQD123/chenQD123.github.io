{"pages":[{"title":"","text":"小帅B )","link":"/album/index.html"},{"title":"","text":"个人简介 搞钱！搞钱！搞钱！铁汁，正能量嗷💪💪💪💪💪💪冲！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 博客信息 白嫖的Icarus主题，感谢主题作者的辛勤付出，下次一定，嘻嘻嘻。 在Icarus主题之上进行了部分修改。 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 其他 陈全蛋网易云音乐歌单分享","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"留言","text":"","link":"/messages/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐&nbsp;&nbsp;&nbsp;点击左下也有音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。","link":"/music/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"IO流为什么要边读编写","text":"本博客的内容包含了字节流，缓冲数组的概念。主要是研究为什么write(bytes)要放在read(bytes)的while循环里，及为啥要一边读，一遍写，而不是读完了（输入），再写（输出）。 今天学习到TCP时,使用Client向Server传入数据，其实这就是一种变相的复制文件，只是输出的目的地是服务器罢了。 下面是服务端的代码，没有任何问题。 1234567891011121314151617181920212223242526272829303132333435363738public class Server { public static void main(String[] args) throws IOException { //1.创建serverSocket对象，传入端口号 ServerSocket serverSocket = new ServerSocket(8888); //2.用serverSocket接收，客户端请求的socket对象 Socket socket = serverSocket.accept(); //3.使用socket对象来获取网络输入流对象，用来读取客户端输出的数据 InputStream is = socket.getInputStream(); //如果文件夹不存在，则创建一个 File file = new File(\"F:\\\\FileUpdate\"); if (!file.exists()){ file.mkdirs(); } //4.创建本地输出流对象 FileOutputStream fos = new FileOutputStream(file+\"\\\\dog.jpg\"); //保存客户端输出的数据 byte[] bytes = new byte[1024]; int len = 0 ; //网络输入流，读取客户端发送的数据，并复制到本地输出流对象指定的目的地 while((len = is.read(bytes))!=-1){ System.out.println(\"保存中\"); fos.write(bytes); } System.out.println(\"wocap\"); //5.利用socket对象，获取网络输出流对象 OutputStream os = socket.getOutputStream(); //6.向客户端发送数据 if (bytes!=null){ os.write(\"你好，你发送的数据已经保存成功\".getBytes()); }else { os.write(\"操作异常，请再次传输数据\".getBytes()); } //7.释放资源 fos.close(); serverSocket.close(); socket.close(); }} 在复制文件时，发生了点小插曲，就是服务器下载不下来文件，所以我就调试，在服务器程序中的读取文件的while循环里打下了断点：结果，在第二次循环时，停下了，紧接着去看照片是否复制好了，的确是由文件，因为执行了一次循环，但是为什么第二次就停止了呢？并且并没有向下执行，而是阻塞在了while循环第一句，我想应该是is.read(bytes)的问题，于是查看API,以下是原文： public int read(byte[] b) throws IOException从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。以整数形式返回实际读取的字节数。在输入数据可用、检测到文件末尾或者抛出异常前， 此方法一直阻塞。如果 b 的长度为 0，则不读取任何字节并返回 0；否则，尝试读取至少一个字节。如果因为流位于文件末尾而没有可用的字节，则返回值 -1；否则，至少读取一个字节并将其存储在 b 中。 将读取的第一个字节存储在元素 b[0] 中，下一个存储在 b[1] 中，依次类推。读取的字节数最多等于 b 的长度。设 k 为实际读取的字节数；这些字节将存储在 b[0] 到 b[k-1] 的元素中，不影响 b[k] 到 b[b.length-1] 的元素。 通过API原文我们可以发现，阻塞在while循环第一句的原因：是没有检测到文件末尾及-1,所以程序一直被阻塞了，而没有向下执行。 那么问题来了，为啥没有我们的文件没有数据了呢，原因只有一个，那就是客户端没有把文件的字节全部输出，所以回头看,发现我们的Client里出现了错误： 1234while((len = fis.read(bytes))!=-1){ System.out.println(\"传输中\"); } os.write(bytes); 对，没错就是今天标题，使用字节流复制文件时，为什么write(bytes)要放在read(bytes)的while循环里,通过API的介绍我们知道了我们形参bytes是一个缓冲数组，所谓缓冲数组，就是暂时放进，但是在再次调用会重新赋值。 于是为了一探究竟我就去看了源码，但是发现他的底层是一个native声明的函数，看不见，native声明的函数是其他语言编写的，如C++，但是我想到了一个方法，怎么研究缓冲数组是否会被重新赋值. 就是通过，每次输出缓冲数组的第一个字节：代码如下： 12345678910111213141516public class copyDemo1 { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\asusc\\\\Pictures\\\\Saved Pictures\\\\dog.jpg\"); FileOutputStream fos = new FileOutputStream(\"F.jpg\"); byte[] bytes = new byte[1024]; int readLen= 0; int i =0; while((readLen= fis.read(bytes))!=-1){ System.out.println(\"缓冲数组第一个字节\"+bytes[0]); } fos.write(bytes,0,readLen); fos.close(); fis.close(); }} 输出结果： 1234567缓冲数组第一个字节-1缓冲数组第一个字节-91缓冲数组第一个字节7缓冲数组第一个字节117缓冲数组第一个字节-86缓冲数组第一个字节-55缓冲数组第一个字节-110 显而易见，我们的思路是对的，缓冲数组，的确会在每次被调用时，被重新赋值。 所以也就说明了为啥write(bytes)要放在read(bytes)的while循环里，及为啥要一边读，一遍写。因为缓冲数组，会被重新赋值，如果把write()放在read()方法的while循环外面，会造成数组越界的异常。上面的例子也会抛出异常，因为write()写数据时，写完那1024个字节的数组，就没了,缓冲数组为空。 下面是客户端向服务器传入数据的正确代码： 客户端 123456789101112131415161718192021222324252627282930313233343536package Net.FileUpdate;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class Client { public static void main(String[] args) throws IOException { //1.创建本地文件输入流，读取本地的文件 FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\asusc\\\\Pictures\\\\Saved Pictures\\\\dog.jpg\"); //2.创建socket对象，传入ip和端口号 Socket socket = new Socket(\"localhost\",8888); //装被读取文件的字节数组 byte[] bytes = new byte[1024]; int len = 0; //3.获取网络输出流的对象，向服务端写入数据 OutputStream os = socket.getOutputStream(); while((len = fis.read(bytes))!=-1){ System.out.println(\"传输中\"); os.write(bytes); } //4.获取网络输入流的对象，用于读取服务器输入的数据 InputStream is = socket.getInputStream(); byte[] bytes1 = new byte[1024]; int len1 = is.read(bytes); System.out.println(new String(bytes1,0,len)); //5.释放资源 fis.close(); socket.close(); }} 服务端 1234567891011121314151617181920212223242526272829303132333435363738394041424344package Net.FileUpdate;import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class Server { public static void main(String[] args) throws IOException { //1.创建serverSocket对象，传入端口号 ServerSocket serverSocket = new ServerSocket(8888); //2.用serverSocket接收，客户端请求的socket对象 Socket socket = serverSocket.accept(); //3.使用socket对象来获取网络输入流对象，用来读取客户端输出的数据 InputStream is = socket.getInputStream(); //如果文件夹不存在，则创建一个 File file = new File(\"F:\\\\FileUpdate\"); if (!file.exists()){ file.mkdirs(); } //4.创建本地输出流对象 FileOutputStream fos = new FileOutputStream(file+\"\\\\dog.jpg\"); //保存客户端输出的数据 byte[] bytes = new byte[1024]; int len = 0 ; //网络输入流，读取客户端发送的数据，并复制到本地输出流对象指定的目的地 while((len = is.read(bytes))!=-1){ System.out.println(\"保存中\"); fos.write(bytes); } System.out.println(\"wocap\"); //5.利用socket对象，获取网络输出流对象 OutputStream os = socket.getOutputStream(); //6.向客户端发送数据 if (bytes!=null){ os.write(\"你好，你发送的数据已经保存成功\".getBytes()); }else { os.write(\"操作异常，请再次传输数据\".getBytes()); } //7.释放资源 fos.close(); serverSocket.close(); socket.close(); }} 好了，博客到现在也就写完了，希望能帮助到遇到此问题的你。","link":"/2024/01/06/IO%E6%B5%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BE%B9%E8%AF%BB%E7%BC%96%E5%86%99/"},{"title":"JDBC笔记","text":"1.使用步骤： 导包 加载驱动类class.forName(….) DriverManager获取sql对象 写sql语句 Statement与prepareStatement不一样的执行sql语句，前者是直接sql对象 . 执行语句，而后者是预处理，即在创建sql对象时，就用sql语句，最后在用对象执行操作。 2.JDBCUtils工具类：就是把使用步骤的共性，提出来，放在一个类中，这样以后就能直接调用创建sql对象的方法就行了。值得一提的是，如果我们使用配置文件，扩展性更好，在使用其他数据库时，我们只需要更改配置文件properties。获取配置文件可以使用properties对象。获取jar包的绝对路径可以使用classLoader类加载器。这样我们就不用自己添加路径了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static{ //读取资源文件，获取值。 try { //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(\"jdbc.properties\"); String path = res.getPath(); //2. 加载文件 pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); //4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); } /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn){ if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 3.DBC控制事务：在执行sql语句时，如果程序执行过程中，发生了异常。比如有两个sql语句，一个是转账操作，一个人存转的这笔钱，如果第一个操作结束后发生了异常。那么这笔钱就会不翼而飞，所以为了避免这样的情况，可以使用事务。 (1)具体操作 开启事务：setAutoCommit( boolean autoCommit ) ：调用该方法设置参数为false，即开启事务。 提交事务：commit( )当所有sql都执行完提交事务。 回滚事务：rollback( ) 在catch中回滚事务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) { PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; Connection con = null; try { con = JDBCUtils.getConnection(); //开启事务 con.setAutoCommit(false); //2.1 张三 - 500 String sql1 = \"update account set balance = balance - ? where id = ?\"; //2.2 李四 + 500 String sql2 = \"update account set balance = balance + ? where id = ?\"; pstmt1 = con.prepareStatement(sql1); pstmt2 = con.prepareStatement(sql2); //4. 设置参数,sql语句里的问号 pstmt1.setDouble(1,500);//填第一个数据 pstmt1.setInt(2,1);//填第二个数据 pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 con.commit(); } catch (SQLException e) { e.printStackTrace(); } catch (Exception e){ try { con.rollback(); } catch (SQLException ex) { ex.printStackTrace(); } } finally{ JDBCUtils.close(con,pstmt1); JDBCUtils.close(con,pstmt2); }} 4.JDBC连接池连接池，就是先创建好一些连接对象，要用的的时候，直接使用，提高了效率，用完之后，归还给连接池，以便其他的使用。 c3p0连接池：步骤： 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，还需要导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml。 路径：直接将文件放在src目录下即可。 创建核心对象 数据库连接池对象 ComboPooledDataSource 获取连接： getConnection代码： 1234//1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); druid：这个是阿里的，性能更好，效率更高。步骤： 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂类来获取 DruidDataSourceFactory 获取连接：getConnection代码：12345678 //3.加载配置文件Properties pro = new Properties();InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\");pro.load(is);//4.获取连接池对象DataSource ds = DruidDataSourceFactory.createDataSource(pro);//5.获取连接Connection conn = ds.getConnection(); 由于代码还是冗长，重复率高，所以可以自定义个工具类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); } public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } } Spring JDBC Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤： 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update():执行DML语句。增、删、改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList():查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query():查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 一般用于聚合函数的查询 12345678 //2. 定义sql //1. 获取JDBCTemplate对象private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());String sql = \"update emp set salary = 10000 where id = 1001\";//3. 执行sqlint count = template.update(sql);System.out.println(count); 这大大简化了我们curd的代码量。","link":"/2024/01/06/JDBC%E7%AC%94%E8%AE%B0/"},{"title":"MySQL基础","text":"MySQLSQL语法：通用语法： SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写。 三种注释 单行注释: – 注释内容 或 # 注释内容(mysql 特有) 多行注释: /* 注释 */ SQL分类 DDL(Data Definition Language)数据定义语言,用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ;DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录* select * from 表名; 1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略 3. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &apos;___&apos;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;","link":"/2024/01/06/MySQL%E5%9F%BA%E7%A1%80/"},{"title":"SpringBoot+shiro+mybatis+Thymeleaf实现权限登录","text":"最近在做一个期末作品，就是使用ssm+thymeleaf+vue+shiro完成一个具有权限登录，且能实现用户信息增删查改的这么一个项目，下面仅仅是实现权限认证和登录。为什么我选shiro，而不选spring Security，是因为我试过，security实在是比较难，封装的太厉害了，哈哈哈哈，所以果断放弃，选择shiro进行。 下一篇还实现了增删查改，使用vue，但是没有前后端分离，博客链接 !github源码连接，需要请自行下载。 提示，这个项目已经有了增删查改，跟着下面的博客做，也能做出来页面跳转权限，但是没有增删查改。 以下是学习shiro的一个小Demo： 1.首先是底层数据库：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-- ------------------------------ Table structure for role-- ----------------------------CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '角色表主键', `role_name` varchar(32) DEFAULT NULL COMMENT '角色名称', PRIMARY KEY (`id`));-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES (1, 'SUPER_ADMIN');INSERT INTO `role` VALUES (2, 'ADMIN');INSERT INTO `role` VALUES (3, 'USER');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键', `username` varchar(32) NOT NULL COMMENT '用户名', `password` varchar(32) NOT NULL COMMENT '密码', `role_id` int(11) DEFAULT NULL COMMENT '与role角色表联系的外键', PRIMARY KEY (`id`), CONSTRAINT `user_role_on_role_id` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`));-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (1, 'BWH_Steven', '666666', 1);INSERT INTO `user` VALUES (2, 'admin', '666666', 2);INSERT INTO `user` VALUES (3, 'zhangsan', '666666', 3);-- ------------------------------ Table structure for permission-- ----------------------------CREATE TABLE `permission` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '权限表主键', `permission_name` varchar(50) NOT NULL COMMENT '权限名', `role_id` int(11) DEFAULT NULL COMMENT '与role角色表联系的外键', PRIMARY KEY (`id`), CONSTRAINT `permission_role_on_role_id` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`));-- ------------------------------ Records of permission-- ----------------------------INSERT INTO `permission` VALUES (1, 'user:*', 1);INSERT INTO `permission` VALUES (2, 'user:*', 2);INSERT INTO `permission` VALUES (3, 'user:queryAll', 3); 2.创建spring boot项目，用maven构建创建实体类（User，Role，Permissions）：User: 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class User { private Integer id; private String username; private String password; //用户对应的角色集合 private Role role;} Role: 123456789@Data@AllArgsConstructor@NoArgsConstructorpublic class Role { private Integer id; private String roleName;} Permissions： 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class Permissions { private Integer id; private String permissionName; private Role role;} 我们需要知道三个实体类之间的关系，User与Role一对一，Role与Permissions一对一，当然也可以把它都写成多对多，这就需要去更改数据库文件，和实体类了。 3.在pom.xml添加相关依赖：下面只给出相关依赖源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 4.整合mybatis和springboot：就只需要创建一个dao层，一个服务层,需要记住要添加注解：（1)mapper配置文件(也可以使用注解形式)： 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.example.csy.dao.UserMapper\"&gt; &lt;select id=\"queryUserByUsername\" resultMap=\"userRoleMap\"&gt; SELECT u.*,r.role_name FROM `user` u, `role` r WHERE username = #{username} AND u.role_id = r.id; &lt;/select&gt; &lt;!-- 定义封装 User和 role 的 resultMap --&gt; &lt;resultMap id=\"userRoleMap\" type=\"com.example.csy.entity.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;!-- 配置封装 UserPojo 的内容 --&gt; &lt;association property=\"role\" javaType=\"com.example.csy.entity.Role\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"queryPermissionByUsername\" resultMap=\"permissionRoleMap\"&gt; SELECT p.* ,r.role_name FROM `user` u, `role` r, `permission` p WHERE username = #{username} AND u.role_id = r.id AND p.role_id = r.id; &lt;/select&gt; &lt;!-- 定义封装 permission 和 role 的 resultMap --&gt; &lt;resultMap id=\"permissionRoleMap\" type=\"com.example.csy.entity.Permissions\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"permissionName\" column=\"permission_name\"&gt;&lt;/result&gt; &lt;!-- 配置封装 Role 的内容 --&gt; &lt;association property=\"role\" javaType=\"com.example.csy.entity.Role\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;!--property是实体类中被赋值的参数名，column是数据库的列名--&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; （2）DAO层： 123456@Mapperpublic interface UserMapper { User queryUserByUsername(@Param(\"username\") String username); Permissions queryPermissionByUsername(@Param(\"username\") String username);} （3）service层： 1234567891011121314151617@Servicepublic class UserServiceImpl implements UserService { @Autowired private UserMapper userMapper; @Override public User queryUserByUsername(String username) { return userMapper.queryUserByUsername(username); } @Override public Permissions queryPermissionByUsername(String username) { return userMapper.queryPermissionByUsername(username); }} 弄到这里，我们的mybatis+springboot整合也基本结束，所以在测试类里测试一下： 1234567891011121314@SpringBootTestclass CsyApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { User admin = userMapper.queryUserByUsername(\"admin\"); System.out.println(admin.toString()); Permissions permission = userMapper.queryPermissionByUsername(\"admin\"); System.out.println(permission.toString()); }} 测试结果：得到了查询结果 6.整合Thymeleaf进来：前端页面：在html页面我们整合了Thymeleaf，使用了Jquery，semantic，需要导包 index.html代码：在这里，如果是User就只能访问A，Admin能访问A,B，superAdmin能访问A,B,C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!DOCTYPE html&gt;&lt;html lang=\"zh_CN\" xmlns:th=\"http://www.thymeleaf.org\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:layout=\"http://www.ultraq.net.nz/web/thymeleaf/layout\" xmlns:shiro=\"http://www.pollix.at/thymeleaf/shiro\"&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;信息管理平台-首页&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\" /&gt; &lt;title&gt;首页&lt;/title&gt; &lt;!--semantic-ui--&gt; &lt;link href=\"https://cdn.bootcss.com/semantic-ui/2.4.1/semantic.min.css\" rel=\"stylesheet\" /&gt; &lt;!--&lt;link href=\"css/index.css\" rel=\"stylesheet\"&gt;--&gt; &lt;link th:href=\"@{/css/index.css}\" rel=\"stylesheet\"&gt; &lt;!-- &lt;script th:src=\"@{js/jquery-3.1.1.min.js}\"&gt;&lt;/script&gt; --&gt; &lt;script src=\"js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"ui container\"&gt; &lt;div class=\"ui secondary menu\"&gt; &lt;a class=\"active item\" th:href=\"@{/index}\"&gt; 首页 &lt;/a&gt; &lt;a class=\"active item\" th:href=\"@{/about}\"&gt; 关于 &lt;/a&gt; &lt;!--登录注销--&gt; &lt;div class=\"right menu\"&gt; &lt;!--如果未登录--&gt; &lt;!--&lt;div shiro:authorize=\"!isAuthenticated()\"&gt;--&gt; &lt;div shiro:notAuthenticated=\"\"&gt; &lt;a class=\"item\" th:href=\"@{/toLoginPage}\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 登录 &lt;/a&gt; &lt;/div&gt; &lt;!--如果已登录--&gt; &lt;div shiro:authenticated=\"\"&gt; &lt;a class=\"item\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 用户名：&lt;span shiro:principal&gt;&lt;/span&gt; &lt;!--角色：&lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt;--&gt; &lt;/a&gt; &lt;/div&gt; &lt;div shiro:authenticated=\"\"&gt; &lt;a class=\"item\" th:href=\"@{/logout}\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 注销 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"ui stackable three column grid\"&gt; &lt;div class=\"column\" shiro:hasAnyRoles=\"USER,ADMIN,SUPER_ADMIN\"&gt;&lt;!--有其中任一一个角色课访问--&gt; &lt;div class=\"ui raised segments\"&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelA/a}\"&gt;L-A-a&lt;/a&gt; &lt;/div&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelA/b}\"&gt;L-A-b&lt;/a&gt; &lt;/div&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelA/c}\"&gt;L-A-c&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\" shiro:hasAnyRoles=\"ADMIN,SUPER_ADMIN\"&gt; &lt;div class=\"ui raised segments\"&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelB/a}\"&gt;L-B-a&lt;/a&gt; &lt;/div&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelB/b}\"&gt;L-B-b&lt;/a&gt; &lt;/div&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelB/c}\"&gt;L-B-c&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\" shiro:hasRole=\"SUPER_ADMIN\"&gt; &lt;div class=\"ui raised segments\"&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelC/a}\"&gt;L-C-a&lt;/a&gt; &lt;/div&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelC/b}\"&gt;L-C-b&lt;/a&gt; &lt;/div&gt; &lt;div class=\"ui segment\"&gt; &lt;a th:href=\"@{/levelC/c}\"&gt;L-C-c&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;div class=\"column\"&gt;&lt;/div&gt; --&gt; &lt;/div&gt; &lt;div class=\"ui stacked segment\"&gt; &lt;div class=\"ui stackable three column grid\"&gt; &lt;div class=\"column\"&gt; &lt;p&gt; 晚风吹起你鬓间的白发&lt;br/&gt; 抚平回忆留下的疤&lt;br/&gt; 你的眼中 明暗交杂 一笑生花&lt;br/&gt; 暮色遮住你蹒跚的步伐&lt;br/&gt; 走进床头藏起的画&lt;br/&gt; 画中的你 低着头说话&lt;br/&gt; 我仍感叹于世界之大 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;p&gt; 也沉醉于儿时情话&lt;br/&gt; 不剩真假 不做挣扎 无谓笑话&lt;br/&gt; 我终将青春还给了她&lt;br/&gt; 连同指尖弹出的盛夏&lt;br/&gt; 心之所动 就随风去了&lt;br/&gt; 以爱之名 你还愿意吗&lt;br/&gt; ❤ &lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;img class=\"ui medium circular image\" src=\"images/001.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"ui info message\"&gt; &lt;div class=\"header\"&gt;理想二旬不止&lt;/div&gt; &lt;p&gt;BWH_Steven&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; login.html代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:layout=\"http://www.ultraq.net.nz/web/thymeleaf/layout\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户管理系统-登录&lt;/title&gt; &lt;!-- &lt;script th:src=\"@{js/jquery-3.1.1.min.js}\"&gt;&lt;/script&gt; --&gt; &lt;script src=\"js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;link href=\"https://cdn.bootcss.com/semantic-ui/2.4.1/semantic.min.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户管理系统-登录&lt;/h1&gt;&lt;div class=\"ui container\" style=\"margin-top: 180px;\"&gt; &lt;div style=\"text-align: center; margin-bottom: 20px;\"&gt; &lt;h1 class=\"header\"&gt; 登录 &lt;/h1&gt; &lt;/div&gt; &lt;div class=\"ui three column stackable grid login-div\"&gt; &lt;div class=\"column\"&gt;&lt;/div&gt; &lt;div class=\"column\"&gt; &lt;form id=\"login\" class=\"ui fluid form segment\" th:action=\"@{/login}\" method=\"post\"&gt; &lt;div class=\"field\"&gt; &lt;label class=\"\"&gt;用户名&lt;/label&gt; &lt;div class=\"ui left icon input\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"\"/&gt; &lt;i class=\"user icon\"&gt;&lt;/i&gt; &lt;div class=\"ui corner label\"&gt; &lt;i class=\"icon asterisk\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"field\"&gt; &lt;label class=\"\"&gt;密码&lt;/label&gt; &lt;div class=\"ui left icon input\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"\"/&gt; &lt;i class=\"lock icon\"&gt;&lt;/i&gt; &lt;div class=\"ui corner label\"&gt; &lt;i class=\"icon asterisk\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"inline field\"&gt; &lt;div class=\"ui checkbox\"&gt; &lt;input type=\"checkbox\" name=\"terms\"/&gt; &lt;label&gt;记住密码&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"inline field\"&gt; &lt;input type=\"submit\" class=\"ui blue submit button\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"column\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; success.html: 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户管理系统-成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;登录成功&lt;/h2&gt;&lt;a href=\"/index\"&gt;返回主页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 7.将shiro整合到项目里：（1）自定义Realm：我们需要自定义，认证和授权： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class UserRealm extends AuthorizingRealm { @Autowired private UserMapper userMapper; /** * @MethodName doGetAuthorizationInfo 授权操作 * @Description 权限配置类 * @Param [principalCollection] * @Return AuthorizationInfo */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { // 获取用户名信息 String username = (String) principalCollection.getPrimaryPrincipal(); // 创建一个简单授权验证信息 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); // 给这个用户设置从 role 表获取到的角色信息 authorizationInfo.addRole(userMapper.queryUserByUsername(username).getRole().getRoleName()); //给这个用户设置从 permission 表获取的权限信息 authorizationInfo.addStringPermission(userMapper.queryPermissionByUsername(username).getPermissionName()); return authorizationInfo; } /** * @MethodName doGetAuthenticationInfo 身份验证 * @Description 认证配置类 * @Param [authenticationToken] * @Return AuthenticationInfo * @Author WangShiLin */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { // 根据在接受前台数据创建的 Token 获取用户名 String username = (String) authenticationToken.getPrincipal();// UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken;// System.out.println(userToken.getPrincipal());// System.out.println(userToken.getUsername());// System.out.println(userToken.getPassword()); // 通过用户名查询相关的用户信息（实体） User user = userMapper.queryUserByUsername(username); if (user != null) { // 存入 Session，可选 SecurityUtils.getSubject().getSession().setAttribute(\"user\", user); // 密码认证的工作，Shiro 来做 AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), \"userRealm\"); return authenticationInfo; } else { // 返回 null 即会抛异常 return null; } }} (2)写配置类shiroConfig：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@Configurationpublic class ShiroConfig { //将自己的验证方式加入容器 @Bean public UserRealm myShiroRealm() { return new UserRealm(); } /** * 配置安全管理器 SecurityManager * * @return */ @Bean public DefaultWebSecurityManager securityManager() { // 将自定义 Realm 加进来 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 关联 Realm securityManager.setRealm(myShiroRealm()); return securityManager; } /** * 配置 Shiro 过滤器 * * @param securityManager * @return */ @Bean public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager) { // 定义 shiroFactoryBean ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 关联 securityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 自定义登录页面，如果登录的时候，就会执行这个请求，即跳转到登录页 shiroFilterFactoryBean.setLoginUrl(\"toLoginPage\"); // 指定成功页面 shiroFilterFactoryBean.setSuccessUrl(\"/success\"); // 指定未授权界面 shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorized\"); // 设置自定义 filter Map&lt;String, Filter&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(\"anyRoleFilter\", new MyRolesAuthorizationFilter()); shiroFilterFactoryBean.setFilters(filterMap); // LinkedHashMap 是有序的，进行顺序拦截器配置 Map&lt;String, String&gt; filterChainMap = new LinkedHashMap&lt;&gt;(); // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon 表示放行 filterChainMap.put(\"/css/**\", \"anon\"); filterChainMap.put(\"/img/**\", \"anon\"); filterChainMap.put(\"/js/**\", \"anon\"); // 指定页面放行，例如登录页面允许所有人登录 filterChainMap.put(\"/toLoginPage\", \"anon\"); // 以“/user/admin” 开头的用户需要身份认证，authc 表示要进行身份认证 filterChainMap.put(\"/user/admin/**\", \"authc\"); // 页面 -用户需要角色认证 filterChainMap.put(\"/levelA/**\", \"anyRoleFilter[USER,ADMIN,SUPER_ADMIN]\"); filterChainMap.put(\"/levelB/**\", \"anyRoleFilter[ADMIN,SUPER_ADMIN]\"); filterChainMap.put(\"/levelC/**\", \"anyRoleFilter[SUPER_ADMIN]\");// filterChainMap.put(\"/levelA/**\", \"roles[USER]\");// filterChainMap.put(\"/levelB/**\", \"roles[ADMIN]\");// filterChainMap.put(\"/levelC/**\", \"roles[SUPER_ADMIN]\"); // /user/admin/ 下的所有请求都要经过权限认证，只有权限为 user:[*] 的可以访问，也可以具体设置到 user:xxx filterChainMap.put(\"/user/admin/**\", \"perms[user:*]\"); // 配置注销过滤器 filterChainMap.put(\"/logout\", \"logout\"); // 将Map 存入过滤器 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap); return shiroFilterFactoryBean; } /** * 整合 thymeleaf * @return */ @Bean(name = \"shiroDialect\") public ShiroDialect shiroDialect(){ return new ShiroDialect(); } 首先我们将自定义的Realm方法，依赖注入进来到容器 12345//将自己的验证方式加入容器 @Bean public UserRealm myShiroRealm() { return new UserRealm(); } 然后是：SecurityManager配置安全管理器 12345678910111213/** * 配置安全管理器 SecurityManager * * @return */ @Bean public DefaultWebSecurityManager securityManager() { // 将自定义 Realm 加进来 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 关联 Realm securityManager.setRealm(myShiroRealm()); return securityManager; } 最后就是自定义的过滤器，控制那些页面需要什么样的角色才能访问，哪些资源需要谁才能访问，并且setSecurityManager，返回一个ShiroFilterFactoryBean。 重点说一下拦截放行（Map）这块：通过 map 键值对的形式存储，key 存储 URL ，value 存储对应的一些权限或者角色等等，其实 key 这块还是很好理解的，例如 ：/css/、/user/admin/ 分别代表 css 文件夹下的所有文件，以及请求路径前缀为 /user/admin/ URL，而对应的 value 就有一定的规范了。 关键：anon：无需认证，即可访问，也就是游客也可以访问authc：必须认证，才能访问，也就是例如需要登录后roles[xxx] ：比如拥有某种角色身份才能访问 ，注：xxx为角色参数perms[xxx]：必须拥有对某个请求、资源的相关权限才能访问，注：xxx为权限参数 （3）自定义一个角色认证过滤器MyRolesAuthorizationFilter：因为我们的角色，只需用有一个角色就能访问到映射页面,shiro默认是hasAllRoles，也就是说，我们要满足所有的身份才能访问，所以需要我们自定义一个hasAnyRoles，任选其一角色即可。 1234567891011121314151617181920212223public class MyRolesAuthorizationFilter extends AuthorizationFilter { @SuppressWarnings({\"unchecked\"}) public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException { Subject subject = getSubject(request, response); String[] rolesArray = (String[]) mappedValue; if (rolesArray == null || rolesArray.length == 0) { //no roles specified, so nothing to check - allow access. return false; } List&lt;String&gt; roles = CollectionUtils.asList(rolesArray); boolean[] hasRoles = subject.hasRoles(roles); for (boolean hasRole : hasRoles) { if (hasRole) { return true; } } return false; }} （4）最后就是controllercontroller是springMvc的前端控制器，接收什么请求，并且返回对应指定的页面（映射）。首先我们先将所以页面的映射写好， PageController: 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Controllerpublic class PageController { @RequestMapping({\"/\", \"index\"}) public String index() { return \"index\"; } @RequestMapping(\"about\") public String toAboutPage() { return \"redirect:http://www.ideal-20.cn\"; } @RequestMapping(\"/toLoginPage\") public String toLoginPage() { return \"views/login\"; } @RequestMapping(\"/levelA/{name}\") public String toLevelAPage(@PathVariable(\"name\") String name) { return \"views/L-A/\" + name; } @RequestMapping(\"/levelB/{name}\") public String toLevelBPage(@PathVariable(\"name\") String name) { return \"views/L-B/\" + name; } @RequestMapping(\"/levelC/{name}\") public String toLevelCPage(@PathVariable(\"name\") String name) { return \"views/L-C/\" + name; } @RequestMapping(\"/unauthorized\") public String toUnauthorizedPage() { return \"views/unauthorized\"; } @RequestMapping(\"/success\") public String toSuccessPage() { return \"views/success\"; }} UserController:上面那两个映射，只是测试，主要是那个login方法，他可以根据我们前台输入的数据，并创建一个token，如果该token能被认证，即返回成功页面，否则就失败。 12345678910111213141516171819202122232425262728293031323334353637383940@Controllerpublic class UserController { @RequestMapping(\"/user/queryAll\") @ResponseBody public String queryAll() { return \"这是 user/queryAll 方法\"; } @RequestMapping(\"/user/admin/add\") @ResponseBody public String adminAdd() { return \"这是 user/adminAdd 方法\"; } @RequestMapping(\"/login\") public String login(String username, String password, HttpServletRequest request) { // 由于是根据name参数获取的，我这里封装了一下 User user = new User(); user.setUsername(username); user.setPassword(password); // 创建出一个 Token 内容本质基于前台的用户名和密码（不一定正确） UsernamePasswordToken token = new UsernamePasswordToken(username, password); // 获取 subject 认证主体（这里也就是现在登录的用户） Subject subject = SecurityUtils.getSubject(); try{ // 认证开始，这里会跳转到自定义的 UserRealm 中 subject.login(token); // 可以存储到 session 中 request.getSession().setAttribute(\"user\", user); return \"views/success\"; }catch(Exception e){ // 捕获异常 e.printStackTrace(); request.getSession().setAttribute(\"user\", user); request.setAttribute(\"errorMsg\", \"兄弟，用户名或密码错误\"); return \"views/login\"; } }} 8.最终效果：首先是http://localhost:8080/index 登录界面： 表单提交后，就返回值到UserController那个Login方法，认证： 这样我们就登录成功了，并且是superAdmin的权限，可以查看A,B,C 而用户张三，只能看见A 到此结束，本博客借鉴：博客,需要源码的请查看此博客。","link":"/2024/01/06/SpringBoot+shiro+mybatis+Thymeleaf%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%99%BB%E5%BD%95/"},{"title":"Tomcat&Servlet","text":"一.Tomcat: web服务软件，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。 修改端口号:在conf/server.xml,也可以在idea中修改 部署web项目的方法有三种 直接将项目放到webapps目录下即可。 配置conf/server.xml文件 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写* 虚拟目录：xml文件的名称 部署项目到idea中，new project，java ee。然后去配置tomcat的配置文件 二.Servlet: 实现： 定义一个类，实现Servlet接口：public class ServletDemo1 implements Servlet 实现接口方法 去web.xml去配置Servlet 12345678910&lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 执行原理： 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的标签体内容。 如果有，则在找到对应的全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 也可以用Servlet3，在创建项目时可以选择，用Servlet3就比较简单，不用去配置web.xml文件，只需要注解配置,其中/demo就是urlPatterns()，和在web.xml配置的原理一样。 1234567@WebServlet(\"/demo\")public class ser implements Servlet{ @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"init\"); } Servlet中的生命周期方法： 被创建：执行init方法，只执行一次 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。在标签下配置 第一次被访问时，创建: &lt;load-on-startup&gt;的值为负数 在服务器启动时，创建: &lt;load-on-startup&gt;的值为0或正整数 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 多个用户同时访问时，可能存在线程安全问题。解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值。比如买票，定义个成员变量，他就会共享。如果同时买票，或者退票，就会出现问题。 提供服务：执行service方法，执行多次:每次访问Servlet时，Service方法都会被调用一次。 被销毁：执行destroy方法，只执行一次。 Servlet被销毁时执行。服务器关闭时，Servlet被销毁， 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源。","link":"/2024/01/06/Tomcat&Servlet/"},{"title":"本站第一篇博客","text":"#coding","link":"/2024/01/06/hello-world/"},{"title":"java验证输入是否为三阶幻方","text":"问题描述：小明最近在教邻居家的小朋友小学奥数，而最近正好讲述到了三阶幻方这个部分，三阶幻方指的是将1~9不重复的填入一个3*3的矩阵当中，使得每一行、每一列和每一条对角线的和都是相同的。三阶幻方又被称作九宫格，在小学奥数里有一句非常有名的口诀：“二四为肩，六八为足，左三右七，戴九履一，五居其中”，通过这样的一句口诀就能够非常完美的构造出一个九宫格来。 4 9 2 3 5 7 8 1 6 有意思的是，所有的三阶幻方，都可以通过这样 一个九宫格进行若干镜像和旋转操作之后得到 。现在小明准备将一个三阶幻方（不一定是上图中的那个）中的一些数抹掉，交给邻居家的小朋友来进行还原，并且希望她能够判断出究竟是不是只有一个解。而你呢，也被小明交付了同样的任务，但是不同的是，你需要写一个程序~输入格式输入仅包含单组测试数据。每组测试数据为一个3*3的矩阵，其中为0的部分表示被小明抹去的部分。对于100%的数据，满足给出的矩阵至少能还原出一组可行的三阶幻方。输出格式如果仅能还原出一组可行的三阶幻方，则将其输出，否则输出“Too Many”（不包含引号）。样例输入0 7 20 5 00 3 0样例输出6 7 21 5 98 3 4数据规模和约定峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 思路：首先通过题目，可以知道其实三阶幻方，只有一种解，其他的全部是通过旋转，镜像得到的，只能旋转4个方法，在镜像，一共八个。暴力破解就完事了。但是怎么个暴力呢，通过观察知道，中间必定为5，而且只需要两个数字，我们就能唯一确定一个三阶幻方了，所以排除0和5，获得前两个数字的索引，我们就能去遍历8种情况，通过这两个索引判断，只要是在对应的位置上相等，既是我们要找的三阶幻方。 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Test4 { public static void main(String[] args) { method1(\"400950000\"); } //输入一个矩阵看他是否存在三阶幻方，甚至有多个 private static void method1(String matrix) { long start = System.currentTimeMillis(); char[] chars = matrix.toCharArray(); int i = 0; //保存2个索引，除5之外 int[] index = new int[2]; int j = 0; //保存所有情况 ArrayList&lt;String&gt; arr = new ArrayList&lt;&gt;(); //遍历字符数组，获取除5外，两个值得索引 for (; i &lt; chars.length; i++) { char a = chars[i]; if (a!= '0' &amp;&amp; a!='5'){ if (j &lt; 2){ index[j] = i; j++; } } //遍历每种可能，看是否相应位置为该值 arr.add(\"492357816\"); arr.add(\"294753618\"); arr.add(\"834159672\"); arr.add(\"438951276\"); arr.add(\"618753294\"); arr.add(\"276951438\"); arr.add(\"816357492\"); arr.add(\"672159834\"); } //保存到int[] System.out.println(Arrays.toString(index)); for (String s : arr) { //将已知的字符数组转换成字符集 char[] tar = s.toCharArray(); if (tar[index[0]] == chars[index[0]] &amp;&amp; tar[index[1]] == chars[index[1]]){ System.out.println(s); break; } } long end = System.currentTimeMillis(); System.out.println(end-start+ \" 毫秒\"); }}","link":"/2024/01/06/java%E9%AA%8C%E8%AF%81%E8%BE%93%E5%85%A5%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%89%E9%98%B6%E5%B9%BB%E6%96%B9/"},{"title":"不用梯子也能用谷歌搜索","text":"谷歌——程序员必备工具。但是谷歌引擎被墙了，内地是用不了的。 1.下载Ghelper：官方地址 2.添加扩展 把Ghelper文件夹拖过来，或者是添加已解压文件。之后就能顺利使用谷歌搜索引擎了。","link":"/2024/01/06/%E4%B8%8D%E7%94%A8%E6%A2%AF%E5%AD%90%E4%B9%9F%E8%83%BD%E7%94%A8%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2/"},{"title":"markdown基础语法","text":"最近在养成写博客的习惯，现在很多的网站都支持Markdown，但是老忘记语法，所以记录一下基础语法。 先说下我感觉的Markdown的优点： 只用写一篇博客，就能复制粘贴到多个社区，大大节省了时间。以下都支持Markdown，是不是感觉很划算，😁！ Github 码云 Cmd-Markdown 知乎 博客园 CSDN 简书 segmentfault 有道云笔记 Ghost Typecho 印象笔记 只用注意文章内容，不用去多想排版。 更多高阶语法请查看菜鸟教程 下文每个一级标题代表一个语法：可以通过旁边的目录，快速定位某个语法！ 1.标题一级标题是:#空格二级标题是:##空格三级标题是: ###空格四级标题是: ####空格 2.段落这是一个段落 这是第二个段落，进行了换行 格式： 1换行直接就回车键，也可以通过HTML语法：&lt;br&gt;&lt;br&gt; 3.字体斜体是一个 *粗体两个 **斜粗体 *** 4.分割线 分割线是*** 5.删除线这条文字被删除格式 1~~删除线这样写~~ 6.下划线下划线 1下划线是&lt;u&gt;&lt;/u&gt; 7.脚注创建脚注格式类似这样 [^1]。[^]: www.baidu.com 格式 12创建脚注格式类似这样 [^]。[^1]: www.baidu.com 8.列表(1)无序列表 无序列表是： *空格文字 无序列表是： *空格文字 无序列表是： *空格文字 (2)有序列表 有序列表格式是： 数字空格文字 有序列表格式是： 数字空格文字 有序列表格式是： 数字空格文字 有序列表格式是： 数字空格文字 前面的数字可以不按顺序写，markdown会为你自动排序，即使你全部都写成1空格文字 (3)列表嵌套 外层1 内层1 内层2 内层3 外层2 内层1 内层1 内层1 语法和上面一样 9.引用 引用自陈全蛋的博客 引用自陈全蛋的博客 引用自陈全蛋的博客 引用也可以循环嵌套 格式： 123&gt; 引用自陈全蛋的博客&gt;&gt; 引用自陈全蛋的博客&gt;&gt;&gt; 引用自陈全蛋的博客 10.代码(1)行内代码我们需要进行输出行内代码： System.out.println() 格式： 1`System.out.println()` (1)代码块你也可以用 ```包裹一段代码，并指定一种语言（也可以不指定）： 123$(document).ready(function () { alert('RUNOOB');}); 格式： 11.链接这是一个github的链接 格式： 12.图片图片使用微博图床：在浏览器中安装一个插件新浪微博插件，把你想要上传的图片直接拖到插件里面，会生成Http连接，在把链接复制到markdown编辑器中即可。 格式： 13.表格 表头 表头 单元格 单元格 单元格 单元格 单元格 单元格 格式： ```","link":"/2024/01/06/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"使用Luhn算法实现信用卡号验证","text":"问题描述：2：信用卡号的验证 【信用卡号的验证】 当你输入信用卡号码的时候，有没有担心输错了而造成损失呢？其实可以不必这么 担心，因为并不是一个随便的信用卡号码都是合法的，它必须通过 Luhn 算法来验 证通过。 该校验的过程： 1、从卡号最后一位数字开始，逆向将奇数位(1、3、5 等等)相加。2、从卡号最后一位数字开始，逆向将偶数位数字，先乘以 2（如果乘积为两位 数，则将其减去 9），再求和。3、将奇数位总和加上偶数位总和，结果应该可以被 10 整除。例如，卡号是：5432123456788881则，奇数位和=35偶数位乘以 2（有些要减去 9）的结果：1 6 2 6 1 5 7 7，求和=35。最后 35+35=70 可以被 10 整除，认定校验通过。请编写一个程序，从键盘输入卡号，然后判断是否校验通过。通过显示：“成功”， 否则显示“失败”。 比如，用户输入：356827027232780 程序输出：成功【参考测试用例】 356406010024817 成功 358973017867744 成功 356827027232781 失败 306406010024817 失败 358973017867754 失败 思路：没什么好说的，暴力破解就完事了，因为这个思路很简单，只需要一层for循环，因为要倒叙遍历，奇数位为i，偶数位就为i-1，然后在相加就好了。 代码实现：12345678910111213141516171819202122232425262728293031323334353637public class Test5 { public static void main(String[] args) { method(\"356827027232780\"); } private static void method(String s) { System.out.println(s.length()); char[] chars = s.toCharArray(); int odd =0; int even =0; for (int i = chars.length-1; i &gt;= 0; ){ //把字符转化成int，先调用抽象方法，放回String，在把String转换为int，或者是强转，但是字符只能为1位 odd += Integer.parseInt(String.valueOf(chars[i])); //如果大于10 //当前偶数 //如果当前为最后一位,偶数啥事不干 if (i == 0){ }else{ int currEven = Integer.parseInt(String.valueOf(chars[i-1])); //如果当前偶数的两倍&gt;=10 if (currEven*2 &gt;= 10){ even += currEven*2-9; }else{ even += currEven*2; } } i -= 2; } if ((even+odd)%10==0){ System.out.println(\"卡号正确\"); }else{ System.out.println(\"卡号错误\"); } }}","link":"/2024/01/06/%E4%BD%BF%E7%94%A8Luhn%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%8F%B7%E9%AA%8C%E8%AF%81/"},{"title":"全排列算法及解决数字搭积木问题","text":"如果你是做这道题不会，那么你可以看这道题的解题思路，如果你是不太理解全排列算法，那么你可以通过这个题来理解。 题目描述：小明最近喜欢搭数字积木。一共有10块积木，每个积木上有一个数字，0~9。 搭积木规则：每个积木放到其它两个积木的上面，并且一定比下面的两个积木数字小。最后搭成4层的金字塔形，必须用完所有的积木。 下面是两种合格的搭法： 请你计算这样的搭法一共有多少种？ 分析一共有10个数字，要我们把所有可行的排列方式都求出来，一时没什么思路，索性就全排列了，把所有排列的情况都求出来，然后在把每种情况都判断一下，是不是就可以得到答案了。 所以全排列怎么写成了第一大问题了。 全排列对于这个问题来说，我们把金字塔当成一个int数组，那么就为 全排列这个数组{0,1,2,3,4,5,6,7,8,9}。 太长了，想不明白呀，所以来看比较少的呗。对于{0,1}全排列，就是把0抽出来，1做全排列，再把1抽出来，0做全排列，对于{0,1,2},就是： 把0抽出来，把1,2做全排列， 把1抽出来，把0，2做全排列， 把2抽出来，把0，1做全排列。 接下来那不就和上面那个{0,1}一样了吗? 这是不是个递归呢?很明显吧。的确是。 那好我们定义一个方法，这个方法的作用是，把list数组全排列，而参数curr表示当前抽出来的那个数，就像上面例子提到的0一样。 提出来了之后呢，是不是要把curr交换了，这样就可以把所有在这个位置上的所有情况列出来了，所以使用一个for循环，来交换curr和后面剩余数组的数(就是上面例子的1，2，3步骤)。 所以紧接着定义一个方法，交换两数swap(list,curr,j);，当然你也可以把这个方法直接写到这个函数里面，但是毕竟不美观，不实用。 重点来了：回溯！！！ 从这张图中，所谓回溯就是要回到上一没有操作过的状态，再去考虑别的情况。就下面这个A,B,C他需要回到上一次抽数出来之前的状态。这样他才能去抽另外一个数，全排列下一种情况。所以我们再写一遍swap(list,curr,j);，把它原来的状态恢复就行了嘛。 问题分析到这了，我们的代码基本上就可以出来了，所以看下代码，如果看不懂在回到我的分析，相信你一定能看懂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Test2 { static int sum ; public static void main(String[] args) { int list[] = {0,1,2,3,4,5,6,7,8,9}; allSort(list,0); System.out.println(sum); } //代表将第a[m]和a[n]相交换 public static void swap(int a[],int m ,int n){ int temp = a[m]; a[m] = a[n]; a[n] = temp; } //调用全排列数组list,curr代表当前放在第一个的为第几个数字，比如开始就为数组第0个数字 public static void allSort(int list[],int curr ){ //如果当前数组的索引等于数组的长了，就将方法加1 if (curr == list.length-1){ check(list); }else { for (int j = curr; j &lt; list.length; j++){ swap(list,curr,j);//交换当前抽出来那个数 allSort(list,curr+1); swap(list,curr,j);//回溯 } } } public static void check(int list[]){ if (list[1] &lt; list[0]) return; if (list[2] &lt; list[0]) return; if (list[3] &lt; list[1]) return; if (list[4] &lt; list[1]) return; if (list[4] &lt; list[2]) return; if (list[5] &lt; list[2]) return; if (list[6] &lt; list[3]) return; if (list[7] &lt; list[3]) return; if (list[7] &lt; list[4]) return; if (list[8] &lt; list[4]) return; if (list[8] &lt; list[5]) return; if (list[9] &lt; list[5]) return; sum++; }} 其实这个全排列都可以当成一个模板了，但是还是推荐大家一定要手敲，自己写代码，写出来了，才是自己的东西。 图片参考：https://blog.csdn.net/Strom72/article/details/80738818","link":"/2024/01/06/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%95%B0%E5%AD%97%E6%90%AD%E7%A7%AF%E6%9C%A8%E9%97%AE%E9%A2%98/"},{"title":"使用SSM+spingboot+vue+shiro实现权限登录和增删查改","text":"之前写了一篇博客是用，ssm+thymeleaf+vue+shiro完成一个具有权限登录，且能增删查改的这么一个项目。当时只记录了登录权限的操作，现在补充一下增删查改的具体实现。 上一篇博客：使用shiro实现登录权限认证详细代码说明。 首先给出完整代码，点击github连接自取。 一、项目需求： 系统需要在spring boot下面开发 数据库可以需要使用mybatis（可以混合jpa开发） 页面用Thymeleaf模板和Vue.js（vuejs组件可以用element UI） 登录权限采用spring boot security 或者shiro框架（任选其一） 工作量不能低于Boot管理系统，界面美观实用 二、使用到的技术栈： 数据库：springBoot，springMvc，mybatis 页面：thymeleaf，semantic,vue，bootstrap，axios 登录权限和认证：shiro 三、开发过程：1. 大致开发流程： 登录：身份认证，权限授权 用户信息：增删查改 2. 具体：2.1使用shiro安全框架：(1)首先编写我们的底层数据库sql语句和持久层entity类：我们需要三张表，User，Role，Permission，定义他们对于登录的作用，首先是通过姓名和密码查询User表是否有这个人，查询结束通过User的外键Role_Id，来映射这个人的角色，然后又通过Role表中的Id，来查询此角色对应的Permission表中的权限。这样我们就将这个人的身份与权限一并操作完，并且跳转到主页index.html，主页会根据权限，来展示对应的可操作事件，例如： USER有查询的权限，ADMIN在USER的基础上可以修改，添加用户信息，SUPER_ADMIN可以删除。 我们需要知道三个实体类之间的关系，User与Role一对一，Role与Permissions一对一，当然也可以把它都写成多对多，这就需要去更改数据库文件，和实体类了。持久层可以使用lombok，让我们可以减少持久类的代码量，减少set，get的编写。 sql代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-- ------------------------------ Table structure for role-- ----------------------------CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '角色表主键', `role_name` varchar(32) DEFAULT NULL COMMENT '角色名称', PRIMARY KEY (`id`));-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES (1, 'SUPER_ADMIN');INSERT INTO `role` VALUES (2, 'ADMIN');INSERT INTO `role` VALUES (3, 'USER');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键', `username` varchar(32) NOT NULL COMMENT '用户名', `password` varchar(32) NOT NULL COMMENT '密码', `role_id` int(11) DEFAULT NULL COMMENT '与role角色表联系的外键', PRIMARY KEY (`id`), CONSTRAINT `user_role_on_role_id` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`));-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (1, 'BWH_Steven', '666666', 1);INSERT INTO `user` VALUES (2, 'admin', '666666', 2);INSERT INTO `user` VALUES (3, 'zhangsan', '666666', 3);-- ------------------------------ Table structure for permission-- ----------------------------CREATE TABLE `permission` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '权限表主键', `permission_name` varchar(50) NOT NULL COMMENT '权限名', `role_id` int(11) DEFAULT NULL COMMENT '与role角色表联系的外键', PRIMARY KEY (`id`), CONSTRAINT `permission_role_on_role_id` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`));-- ------------------------------ Records of permission-- ----------------------------INSERT INTO `permission` VALUES (1, 'user:*', 1);INSERT INTO `permission` VALUES (2, 'user:*', 2);INSERT INTO `permission` VALUES (3, 'user:queryAll', 3); entity层比较简单，不贴代码： （2）接下来就是pom.xml添加相关依赖，这里就不贴代码了,需要的github自取。（3）整合mybatis和springboot：就只需要创建一个dao层，一个服务层,需要记住要添加注解，一定要清楚他们的对应关系： ① mapper配置文件(也可以使用注解形式)： UserMapper.xml代码 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.example.csy.dao.UserMapper\"&gt; &lt;select id=\"queryUserByUsername\" resultMap=\"userRoleMap\"&gt; SELECT u.*,r.role_name FROM `user` u, `role` r WHERE username = #{username} AND u.role_id = r.id; &lt;/select&gt; &lt;!-- 定义封装 User和 role 的 resultMap --&gt; &lt;resultMap id=\"userRoleMap\" type=\"com.example.csy.entity.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"password\" column=\"password\"&gt;&lt;/result&gt; &lt;result property=\"roleId\" column=\"role_id\"&gt;&lt;/result&gt; &lt;!-- 配置封装 UserPojo 的内容 --&gt; &lt;association property=\"role\" javaType=\"com.example.csy.entity.Role\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"queryPermissionByUsername\" resultMap=\"permissionRoleMap\"&gt; SELECT p.* ,r.role_name FROM `user` u, `role` r, `permission` p WHERE username = #{username} AND u.role_id = r.id AND p.role_id = r.id; &lt;/select&gt; &lt;!-- 定义封装 permission 和 role 的 resultMap --&gt; &lt;resultMap id=\"permissionRoleMap\" type=\"com.example.csy.entity.Permissions\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"permissionName\" column=\"permission_name\"&gt;&lt;/result&gt; &lt;result property=\"roleId\" column=\"role_id\"&gt;&lt;/result&gt; &lt;!-- 配置封装 Role 的内容 --&gt; &lt;association property=\"role\" javaType=\"com.example.csy.entity.Role\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;!--property是实体类中被赋值的参数名，column是数据库的列名--&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; ② dao层与service也比较简单。 ③ 弄到这里我们的mybatis+springboot整合也基本结束，所以在测试类里测试一下： 1234567891011121314@SpringBootTestclass CsyApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { User admin = userMapper.queryUserByUsername(\"admin\"); System.out.println(admin.toString()); Permissions permission = userMapper.queryPermissionByUsername(\"admin\"); System.out.println(permission.toString()); }} （4）将shiro整合到项目里：①.shiro最关键的就是Realm组件： 其可以理解为 Shiro 与 数据之间的沟通器与中间桥梁认证授权时，就会去此部分找一些内容，从本质上 Realm 就是一个经过了大量封装的安全 Dao，这是官网的介绍，我的理解对于Realm组件其实就是一个Dao，我们在这里面定义两个方法，一个身份认证doGetAuthenticationInfo，一个授权doGetAuthorizationInfo，这两个方法很关键，所以给出全部代码： ***UserRealm代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UserRealm extends AuthorizingRealm { @Autowired private UserMapper userMapper; /** * @MethodName doGetAuthorizationInfo 授权操作 * @Description 权限配置类 * @Param [principalCollection] * @Return AuthorizationInfo */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { // 获取用户名信息 String username = (String) principalCollection.getPrimaryPrincipal(); // 创建一个简单授权验证信息 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); // 给这个用户设置从 role 表获取到的角色信息 authorizationInfo.addRole(userMapper.queryUserByUsername(username).getRole().getRoleName()); //给这个用户设置从 permission 表获取的权限信息 authorizationInfo.addStringPermission(userMapper.queryPermissionByUsername(username).getPermissionName()); return authorizationInfo; } /** * @MethodName doGetAuthenticationInfo 身份验证 * @Description 认证配置类 * @Param [authenticationToken] * @Return AuthenticationInfo * @Author WangShiLin */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { // 根据在接受前台数据创建的 Token 获取用户名 String username = (String) authenticationToken.getPrincipal(); // 通过用户名查询相关的用户信息（实体） User user = userMapper.queryUserByUsername(username); if (user != null) { // 存入 Session，可选 SecurityUtils.getSubject().getSession().setAttribute(\"user\", user); // 密码认证的工作，Shiro 来做 AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), \"userRealm\"); return authenticationInfo; } else { // 返回 null 即会抛异常 return null; } }} ②接下来就是编写ShiroConfig注解类： 将所有类，属性全部注入spring容器中，但是我们使用springboot，直接使用注解：@Configuration。该注解类主要是要将，realm类的两个自定义的方法注入，还有配置安全管理器 SecurityManager，还有就是过滤器，这个过滤器是分配权限的一个关键方法，对于这个过滤器，shiro有一个封装好的ShiroFilterFactoryBean工厂类，他有很多自定义方法，set登录页，成功页，未授权页等，这个通过springMvc的控制器控制就行。重点说一下拦截放行（Map）这块：通过 map 键值对的形式存储，key 存储 URL ，value 存储对应的一些权限或者角色等等，其实 key 这块还是很好理解的，例如 ：/css/、/user/admin/ 分别代表 css 文件夹下的所有文件，以及请求路径前缀为 /user/admin/ URL，而对应的 value 就有一定的规范了。如下面的一些shiro自定好的权限 关键：anon：无需认证，即可访问，也就是游客也可以访问authc：必须认证，才能访问，也就是例如需要登录后roles[xxx] ：比如拥有某种角色身份才能访问 ，注：xxx为角色参数perms[xxx]：必须拥有对某个请求、资源的相关权限才能访问，注：xxx为权限参数 就比如我们自己的图片，static文件下所有数据都可以直接使用anon，直接放行，不用管理。 shiroConfig配置类的所有代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Configurationpublic class ShiroConfig { //将自己的验证方式加入容器 @Bean public UserRealm myShiroRealm() { return new UserRealm(); } /** * 配置安全管理器 SecurityManager * * @return */ @Bean public DefaultWebSecurityManager securityManager() { // 将自定义 Realm 加进来 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 关联 Realm securityManager.setRealm(myShiroRealm()); return securityManager; } /** * 配置 Shiro 过滤器 * * @param securityManager * @return */ @Bean public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager) { // 定义 shiroFactoryBean ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 关联 securityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 自定义登录页面，如果登录的时候，就会执行这个请求，即跳转到登录页 shiroFilterFactoryBean.setLoginUrl(\"/toLoginPage\"); // 指定成功页面 shiroFilterFactoryBean.setSuccessUrl(\"/success\"); // 指定未授权界面 shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorized\"); // 设置自定义 filter Map&lt;String, Filter&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(\"anyRoleFilter\", new MyRolesAuthorizationFilter()); shiroFilterFactoryBean.setFilters(filterMap); // LinkedHashMap 是有序的，进行顺序拦截器配置 Map&lt;String, String&gt; filterChainMap = new LinkedHashMap&lt;&gt;(); // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon 表示放行 filterChainMap.put(\"/css/**\", \"anon\"); filterChainMap.put(\"/img/**\", \"anon\"); filterChainMap.put(\"/js/**\", \"anon\"); // 指定页面放行，例如登录页面允许所有人登录 filterChainMap.put(\"/toLoginPage\", \"anon\"); // 以“/user/admin” 开头的用户需要身份认证，authc 表示要进行身份认证 filterChainMap.put(\"/user/admin/**\", \"authc\"); // 页面 -用户需要角色认证// filterChainMap.put(\"/levelA/**\", \"anyRoleFilter[USER,ADMIN,SUPER_ADMIN]\"); filterChainMap.put(\"/levelB/**\", \"anyRoleFilter[ADMIN,SUPER_ADMIN]\");// filterChainMap.put(\"/levelC/**\", \"anyRoleFilter[SUPER_ADMIN]\");// filterChainMap.put(\"/levelA/**\", \"roles[USER]\");// filterChainMap.put(\"/levelB/**\", \"roles[ADMIN]\");// filterChainMap.put(\"/levelC/**\", \"roles[SUPER_ADMIN]\"); // /user/admin/ 下的所有请求都要经过权限认证，只有权限为 user:[*] 的可以访问，也可以具体设置到 user:xxx filterChainMap.put(\"/user/admin/**\", \"perms[user:*]\"); // 配置注销过滤器 filterChainMap.put(\"/logout\", \"logout\"); // 将Map 存入过滤器 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap); return shiroFilterFactoryBean; } /** * 整合 thymeleaf * @return */ @Bean(name = \"shiroDialect\") public ShiroDialect shiroDialect(){ return new ShiroDialect(); }} ④自定义一个角色认证过滤器MyRolesAuthorizationFilter： 因为我们的角色，只需用有一个角色就能访问到映射页面,shiro默认是hasAllRoles，也就是说，我们要满足所有的身份才能访问，所以需要我们自定义一个hasAnyRoles，任选其一角色即可。 12345678910111213141516171819public class MyRolesAuthorizationFilter extends AuthorizationFilter { @SuppressWarnings({\"unchecked\"}) public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException { Subject subject = getSubject(request, response); String[] rolesArray = (String[]) mappedValue; if (rolesArray == null || rolesArray.length == 0) { //no roles specified, so nothing to check - allow access. return false; } List&lt;String&gt; roles = CollectionUtils.asList(rolesArray); boolean[] hasRoles = subject.hasRoles(roles); for (boolean hasRole : hasRoles) { if (hasRole) { return true; } } return false; }} （5）将整合Thymeleaf和semantic进来：Ui我们使用的是semantic，感觉还可以：接下来，就直接展示页面效果了：我们对各种角色对数据库的操作进行了权限的限制，如开头所说，USER有查询的权限，ADMIN在USER的基础上可以修改，添加用户信息，SUPER_ADMIN可以删除。我们实现这种操作，是对表格的一部分标签设置了部分角色才能查看：关键代码是index主页中标签的声明： A.USER有查询的权限shiro:hasAnyRoles=”SUPER_ADMIN,ADMIN,USER” B.ADMIN在USER的基础上可以修改shiro:hasAnyRoles=”SUPER_ADMIN,ADMIN” C.SUPER_ADMIN在ADMIN权限上可以删除shiro:hasAnyRoles=”SUPER_ADMIN” （6）最后就是controller，由于比较简单，就不写代码了。（7）shiro效果展示：登录login.html USER权限: admin权限： SUPER_ADMIN权限： 至此shiro实现登录的身份认证和权限分配操作已经搞定，接下来就是用户信息的增删查改： 2.2实现用户信息的增删查改：（1）dao（mapper）层和service层的编写：由于使用的mybatis，所以我们需要有两种方式，一种是使用注解，一种是编写配置文件，在项目里，两种方式，都使用了的。对于两个一对多的查询使用的是配置文件形式，其他的增、删、改都是用的是注解形式,由于mapper类比较简单就不贴代码了，还有一个UserMapper.xml配置文件的代码，已经在shiro那里贴出来了，这里也不书写了。然后就是service类的编写，我们使用@Service注解，接口和实现类都需要@service注解，然后在实现类中通过mapper调用方法，再加上一些限制如：增加用户信息时，如果该用户存在，就打印失败，方法直接结束。 （2）编写测试类：写了测试成功之后，如果出错，我们可以不用担心是DAO层和service出错了。 12345678910111213141516171819202122232425262728@Test void queryAll(){ List&lt;User&gt; users = userService.queryAll(); System.out.println(users); } @Test void contextLoads() { User admin = userService.queryUserByUsername(\"admin\"); System.out.println(admin.toString()); Permissions permission = userService.queryPermissionByUsername(\"admin\"); System.out.println(permission.toString()); } @Test void addTest() { User user = new User(\"wu\",\"123\",3); int i = userService.addUser(user); System.out.println(i); } @Test void deleteTest() { userService.deleteUser(\"zhangsan\"); } @Test void updateTest() { User user = new User(\"ww\",\"123\",3); }} （3）显示数据到主页index.html上：主要使用vue，axios将数据显示到页面，使用vue的指令，比如v-for，v-model等，ui使用的是semantic，bootstrap，我们将数据操作分为四步怎么实现的。 A.查询所有： 在mapper的定义中，我们有一个queryAll()方法，在controller中，我们返回一个List，所以index中获取这个list，就是最关键的问题了，这里我们在index页面中直接把vue对象定义出来，var vm = new Vue()；将数据显示的表格定义一个id，这个id由vue代理。只需要在data属性里，定义一个数组userList，来将queryAll查询到的list数据赋值到userList数组里。当然查询这个方法，按我们的一般体验来说，应该要登录了就显示，所以axios就起到作用了，他可以让我们不用刷新就把数据显示到页面上，而且在vue中使用axios也比较的方便。我们需要考虑一个问题，就是查询操作应该多久显示，我们知道vue对象使用声明周期的，我们可以在创建vue对象之后就调用queryAll方法，这样就可以实现一登录就查询所有的操作了。在这里我们只需要在vue对象中添加两个方法，一个queryAll，一个create方法。需要值得注意的是我们给userList赋值时，需要声明一个变量 var _this = this;因为vue对象，和axios是不一样的，只有将this赋值，才会调用vue中的对象userList，不然则会调用axios的this，当然我们没有写，所以如果这样写出来，会发现什么数据都没有。赋值userList后，就只需要展示，使用v-for指令，和取值符号就解决了。 Vue代码部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 var vm = new Vue({ el: \"#app\", data: { user: {id:\"\", username:\"\", password:\"\", roleId:\"\", role:{id:\"\",roleName:\"\"} }, userList: [], wo:\"ri\" }, methods: { addUser:function (user) { var _this = this; axios.post(\"/user/admin/add\",_this.user).then(function (response) { _this.queryAll(); console.log(_this.userList); }).catch(function (err) { console.log(_this.user); console.log(err); }); }, deleteUser:function (username) { var _this = this; axios.post(\"/user/admin/delete\",username=username).then(function (response) { _this.queryAll(); }).catch(function (err) { }); }, queryAll: function () { var _this = this; axios.get(\"/user/queryAll\").then(function (response) { _this.userList = response.data; console.log(_this.userList); }).catch(function (err) { console.log(err); }); }, queryByName: function (username) { var _this = this; axios.get(\"/user/queryByName\", { params: { username: username } }).then(function (response) { _this.user = response.data; $('#updateModal').modal(\"show\"); console.log(_this.user); }).catch(function (err) { console.log(err); }); }, updateUser: function (user) { var _this = this; axios.post(\"/user/admin/update\",_this.user).then(function (response) { _this.queryAll(); console.log(_this.user); }).catch(function (err) { }); } }, created(){ this.queryAll(); } }); Html表格那部分代码比较简单就不贴了。 B.删除用户： 对于删除用户，我们可以再每个查询结果后弄一个td，这样我们就可以获取当前这一行的user的id，方便赋值，这里我们使用v-on：，直接调用vue中定义的方法deleteUser（id），在这里我们也使用axios.post()，因为我们要传参数，执行操作，deleteUser方法的代码就在上面，同时我们需要在执行完操作之后，直接查询所有方法queryAll，所以我们需要在delete结束后，调用_this.queryAll()方法。这样交互性比较好。 C.修改用户： 修改用户我们可以使用bootstrap中的模态框，使用模态框的好处，就是交互性好，不需要跳转页面，使用起来更加简洁。使用模态框也不是很难，就只需要在div标签中的class使用bootstrap的语法，在点击修改之后，会调用queryByName方法，在方法中使用取值符号来获取模态框的id并且调用bootstrap封装的moal(“show)方法，显示模态框。_this.user = response.data;$(‘#updateModal’).modal(“show”); E.增加用户： 增加用户和修改用户差不多，也是v-model实现，只不过加了提示，当然后续操作和上面一样，也是直接queryAll(),还有一点因为网页传给我们的数据时json，所以需要在controller中使用@RequestBody将json转换成字符串，如果有返回值也要使用@ResponseBody。因为要赋值。 到此开发就结束了。 四、实验成果展示：实现的效果大家可以克隆下来源代码自己测试，这里我只给出一些大概的展示。（1）增加用户： 本博客内容基本到此结束，如果觉得有用的，你懂得，码字不易！嘻嘻！","link":"/2024/01/06/%E4%BD%BF%E7%94%A8SSM+spingboot+vue+shiro%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%99%BB%E5%BD%95%E5%92%8C%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/"},{"title":"力扣——二叉搜索树的范围和","text":"题目： 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。 二叉搜索树保证具有唯一的值。 示例 1： 输入：root = [10,5,15,3,7,null,18], L = 7, R = 15 输出：32 示例 2： 输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 输出：23 提示： 树中的结点数量最多为 10000 个。 最终的答案保证小于 2^31。 思路：首先是题意：这道题的意思就是，找出在给定左右节点范围中的节点数的和。 所以我们可以遍历所有节点，于是我们可以使用递归。 法一，使用递归但是方法作用与法二不同，作用写在了代码的第一句，法三就是用while循环，遍历每个节点 代码：main函数： 123456789101112131415161718192021222324252627282930313233343536class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }}//递归实现深度优先搜索public class 二叉搜索树的范围和 { static int result; static int ans; public static void main(String[] args) { result = 0; //第一层 TreeNode node = new TreeNode(10); //第二层 node.left = new TreeNode(5); node.right = new TreeNode(15); //第三层 node.left.left = new TreeNode(3); node.left.right = new TreeNode(7); node.right.right = new TreeNode(18); //法一，递归但是方法作用与法二不同，递归实现深度优先遍历：// dfs(node,7, 15);// System.out.println(result); //法二：// System.out.println(dfs2(node,7,15)); //法三,迭代实现深度优先遍历: f3(node,7,15); System.out.println(ans); } 法一： 1234567891011//当前节点是否能进入result的和,遍历了所有节点 public static void dfs(TreeNode node, int l, int r) { if (node != null){ if (l &lt;= node.val &amp;&amp; node.val &lt;= r) { result += node.val; } //这里必须要遍历每个节点，所以需要node.val &gt; l ,dfs(node.left,l,r) if (node.val &gt; l) dfs(node.left,l,r); if (node.val &lt; r) dfs(node.right,l,r); } } 法二： 12345678910111213141516//该树的满足范围的和,，没有遍历所有节点 //如果当前节点的值小于left，和等于右子数之和 //如果当前节点的值大于right，和等于左子数之和 //如果当前节点的值在范围里，和等于右子数+左子树之和+当前节点的值 private static int dfs2(TreeNode node, int l, int r) { if (node == null) { return 0; } if (node.val &lt; l){ return dfs2(node.right,l,r); } if (node.val &gt; r){ return dfs2(node.left,l,r); } return dfs2(node.left,l,r)+dfs2(node.right,l,r)+node.val; } 法三： 12345678910111213141516171819//迭代实现深度优先遍历，遍历了所有节点 public static int f3(TreeNode root,int L, int R){ ans = 0; Stack&lt;TreeNode&gt; stack = new Stack(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node != null) { if (L &lt;= node.val &amp;&amp; node.val &lt;= R) ans += node.val; if (L &lt; node.val) stack.push(node.left); if (node.val &lt; R) stack.push(node.right); } } return ans; }","link":"/2024/01/06/%E5%8A%9B%E6%89%A3%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/"},{"title":"力扣——划分为k个相等的子集","text":"一、题目： 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例 1： 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 提示： 1 &lt;= k &lt;= len(nums) &lt;= 16 0 &lt; nums[i] &lt; 10000 二、思路：首先是题意：做每道算法题，最重要的是，读懂题意，从分析我们可以得出来的是，目标值及每个子集的和target=sum(nums)/k,所以就确定了目标值target。得出目标值后，我们可以得到一些一定为false的情况，如 目标值不为整数 nums中有值大于target的 我们还可以先找出nums中是否有等于target的值，这道题的思路就是把nums所有元素都放进长度为k的groups数组当中，如果刚刚放完，则返回true。对于放进groups这个动作我们称它为搜索元素放进group，对于一共k个子集的我们只需要一个for循环就能解决。使用递归我们可以做到一直搜索。只用改变当前搜索的值，就能一直向group数组中添加。如果看不懂思路，请结合代码分析。 三、代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class 划分为k个相等的子集 { public static void main(String[] args) { 划分为k个相等的子集 a = new 划分为k个相等的子集(); int[] nums = {4, 3, 2, 3, 5, 2, 1}; System.out.println(a.canPartitionKSubsets(nums,4)); } public boolean canPartitionKSubsets(int[] nums, int k) { int sum = Arrays.stream(nums).sum(); if (sum % k &gt; 0) return false; //由题意我们可以知道目标值绝对是sum/k int target = sum / k; //给nums数组排序，递增顺序 Arrays.sort(nums); int row = nums.length - 1; //如果最大的值大于目标值，则改数组肯定不满足条件，直接返回false if (nums[row] &gt; target) return false; //如果有等于目标值的，k--，row-- while (row &gt;= 0 &amp;&amp; nums[row] == target) { row--; k--; } return search(new int[k], row, nums, target); } //函数作用：搜索nums中的每一个数，能不能添加到groups里，并且和等于target，row代表当前添加到groups中的数 public boolean search(int[] groups, int row, int[] nums, int target) { //如果nums中没有数了，则代表所有数全部放入groups中 if (row &lt; 0) return true; //注意row--，先赋值，再-- int v = nums[row--]; //遍历groups的k个子集 for (int i = 0; i &lt; groups.length; i++) { if (groups[i] + v &lt;= target) { groups[i] += v; if (search(groups, row, nums, target)) return true; //不能添加到groups中，则把它减去，及回溯 groups[i] -= v; } //如果遍历完了，所有数都不能放进groups中，及没有值相加或者本身等于target，则跳出循环break,或者return false; if (groups[i] == 0) return false; } return false; }}","link":"/2024/01/06/%E5%8A%9B%E6%89%A3%E2%80%94%E2%80%94%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/"},{"title":"力扣——最长同值路径","text":"一、题目： 给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 输入: 5 / \\ 4 5 / \\ \\ 1 1 5 输出: 2 示例 2: 输入: 1 / \\ 4 5 / \\ \\ 4 4 5 输出: 2 注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。 二、思路：这道题的题意就是找出二叉树，最长同值路径。分为两种情况（1）从根节点出发，左子树的最长同值路径（2）从根节点出发，右子数的最长同值路径而有一种特殊的是，根节点在中间，就比如实例2的同值4，这种，只需要再我们遍历二叉树的时候，去判断，是否 左右子节点与根节点相等就行了，那么与就需要最长路径就需要+2，（1）（2）就只需要+1。对于二叉树这种数据结构，很明显的使用递归去遍历左右子树就行了。 三、代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }}public class 最长同值路径 { static int ans; public static void main(String[] args) { //第一层 TreeNode node = new TreeNode(1); //第二层 node.left = new TreeNode(4); node.right = new TreeNode(4); //第三层 node.left.left = new TreeNode(4); node.left.right = new TreeNode(4); node.right.right = new TreeNode(5); System.out.println(longestUnivaluePath(node)); } public static int longestUnivaluePath(TreeNode root) { ans = 0; longestPath(root); return ans; } //递归函数功能：搜寻以node为起点的最长同值路径:要么是以node为起点的左子树，要么是以node为起点的右子树 public static int longestPath(TreeNode node) { if (node == null) return 0; int maxLorRres = 0; int left = longestPath(node.left); //node左子树的最长同值路径 int right = longestPath(node.right);//node右子树的最长同值路径 //这种情况对于寻找最长同值路径长有帮助，对于搜索以root为路径起始点的最长路径没有帮助 if (node.left != null &amp;&amp; node.left.val == node.val &amp;&amp; node.right != null &amp;&amp; node.right.val == node.val) { ans = Math.max(ans, left + right + 2); } //从左右子树中选择最长的同值路径 if (node.left != null &amp;&amp; node.left.val == node.val) { maxLorRres = left + 1; } if (node.right != null &amp;&amp; node.right.val == node.val) { maxLorRres = Math.max(maxLorRres, right + 1); } //从ans与maxLorRres中更新最大值 ans = Math.max(ans, maxLorRres); //返回节点的左右最大的同值的值 return maxLorRres; }}","link":"/2024/01/06/%E5%8A%9B%E6%89%A3%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/"},{"title":"力扣——第N个泰波那契数列的值","text":"力扣1137——第N个泰波那契数列的值 题目： 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。 示例 1： 输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2： 输入：n = 25 输出：1389537 提示： 0 &lt;= n &lt;= 37 答案保证是一个 32 位整数，即 answer &lt;= 2^31 - 1。 思路及代码：有题目的本意就知道了，这是一个递归，所以最简单的办法就是递归四步走，确定参数，定义函数作用，递归出口，等价条件。但是通过这种方法，会造成大量的重复计算，可以画个树，他的杂度是以3^n。 所以我们可以使用动态规划： 法一：动态规划+递归：找个数组来装第N个泰波那契数列的值，每次递归就判断，是否数组中是否有这个值。 12345678910public static int f2(int n){ int result = 0; if (dp[n] != 0) return dp[n]; if (n == 0) return 0; if (n == 1 || n == 2) return 1; //把当前的值放进dp中，进行记录，下次遇到了要算这个f(n)就拿出来用 result = f2(n-1) + f2(n-2)+ f2(n-3); dp[n] = result; return result; } 法二：动态规划非递归，三个数一直保存，当前计算的n的前三项的值。 12345678910111213public static int f3(int n){ if (n &lt; 3) return n == 0 ? 0:1; //定义三个变量，装临时值 int a=0 ,b=1, c=1; for (int i = 3; i &lt;= n; i++){ int temp = a + b + c; a = b; b = c; c = temp; } //c就是最终的结果 return c; } 法三：动态规划，自底向上 123456789public static int f4(int n){ int dp[] = new int[n+3]; dp[1] = 1; dp[2] = 1; for (int i = 3; i &lt;= n; i++){ dp[i] = dp[i-1] + dp[i-2]+ dp[i-3]; } return dp[n]; }","link":"/2024/01/06/%E5%8A%9B%E6%89%A3%E2%80%94%E2%80%94%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E5%80%BC/"},{"title":"扩展欧几里得","text":"扩展欧几里得定理扩展欧几里得定理（Extended Euclidean algorithm, EXGCD），常用于求ax+by=gcd(a,b) 的一组可行解。 将 不断代入递归求解直至 （最大公约数，下同）为 0 递归 x=1,y=0 回去求解。 123456789101112public static int f(int a,int b,int[] xy){ if(b == 0){ xy[0] = 1; xy[1] = 0; return a; } int gcd = f(b,a%b,xy); int t = xy[0]; //t = x2; xy[0] = xy[1]; //x1 = y2; xy[1] = t - a/b*xy[1]; //y1 = x2 - a/b*y2 return gcd; } 这里要传一个数组，因为，最后要获取被改变的x，y的值。c语言用指针也可以，传地址。 函数参数的传递的是值，swap(int a,int b)中，a和b都只是得到了实参的值而已，然后就跟实参没有任何关系了。 如果用swap(int* a,int* b)，依然是得到实参的值，但由于a,b是指针，得到的将是地址，那么参数和实参所指的地址是一样的，如果在函数体里交换地址所指的存储内的东西，那么就是真的交换了。","link":"/2024/01/06/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"title":"回顾迷茫的大一大二","text":"“下学期我一定好好学习”，到了大二上，这是我第三次对室友说了，不知道这句flag是不是全国统一。反正对我来说，这的确是一句flag。 从压抑的高中到自由的大学，这无疑是天堂。不知道有多少个高中夜里，我曾想象着：大学美好的校园爱情，想象着校园活动多么多姿多彩，想象着老师多么有趣，反正觉得大学的空气都是甜的。初到学校，这的确挺美好的，除了有点旧。。。 学校通知我们写一封“写给四年后的自己”的信，虽然已经记不到自己写的什么了，但是肯定很美好吧。 我喜欢唱歌，经过一轮面试，成功成为了一名队员。心想：肯定会遇见很多很美好的人或事吧，充满期待。和室友打成一片后，注册了差不多一样的名字的号，开始了五黑之旅，胜率55开吧，但也还不错。由于我是软工专业的，大一学习C语言，那叫一个“天书”，逐渐养成了上课玩手机的习惯，开始，还不觉得什么，到了讲指针，就没听过了，哈哈哈。真的就是天书吗？我可是打引号了的。大一上最高兴的一次，大概是和室友出去吃自助餐，那天下着小雨，我们几个人，撑到炸裂，还顺走了餐馆几瓶饮料，回学校的路上，下着小雨，挺诗意的。后来还和室友去了一些景点。时间来到了期末考试，我开始泡图书馆，学习着“天书”，看着空白的教材，这就是0的突破嘛，哈哈。不过还好，凭借着临时抱佛脚，还真没挂科，居然还考了专业二十来名。就离谱。 夏天是最美的季节，不如说是人更美。爱情向来都是要主动地，学校里这么多女生，都还没交女朋友，实在说不过去，我心想道。那天，下课的时候，一个女生正和同桌闲聊。惊鸿一瞥，淦！这妹子真tm好看。于是凭借着强大的皮肤厚度，要到了这个女生的联系方式。第一次约会，我定在了电影院，电影名字叫《何以为家》讲的是一个小孩带着妹妹流浪展的开一系列的事。很戏剧性的，我把票买错了，电影都开始了。哭笑不得，所以我俩就去逛商城，她是学语文的，通过聊天感觉这个女生真的好温柔。在发起猛烈攻势后，过了一段时间后，终于还是抱得美人归。大一下结。 大二上我依然对室友说着熟悉的flag，“这学期我一定好好学习”。好家伙，云顶之弈，悄然上线，本来已经弃坑的LOL，又响起了熟悉的bgm，沉迷云顶。女朋友话贼多，自从我经常打游戏，就很少和女朋友交流。后来才知道她为啥不给我发消息，只要一看见我是电脑在线，就不理我了，哈哈哈。感情需要两个人维护，最后还是分手了。大二上学java时，是一个魔鬼老师在讲课，只有靠提前预习才能听懂，从来不预习的我，撑到到了毛概课，上毛概不玩手机，就看java，终于java还是考了八十多分，大学的考试，我觉得真的是很简单，不会考高深的，只考基础，所以这分数也就没含金量。 时间到了寒假，很不幸的爆发了疫情。在家学习的我，依然对自己说“这学期我一定好好学习”，这句flag，终于没打我脸了，我跟着网课学习，确实学到了不少东西。是环境造成的？在学校大家都打游戏，你不玩就显得格格不入，其实问自己心理，难道自己不想玩？终究问题还是在自己身上。就这样大一大二宣告破产。 “生活就像一块巧克力，你永远不知道下一块是什么味道”既然都是自己选择的巧克力，作为成年人，就要接受，控制权在自己手上。只有自己才能把握自己的未来，生活本就由自己书写，由自己选择。回顾我的大一大二，有甜，有苦的巧克力，但是青春要是没一点迷茫，一直按部就班也太没意思了。既然过去已经过去，也只能当做回忆，那最重要的就是现在。确定好自己的目标，就去冲，年轻人，要是没一点血性，还叫年轻人？希望两年之后呢，我也选择到了那块的甜味巧克力。","link":"/2024/01/06/%E5%9B%9E%E9%A1%BE%E8%BF%B7%E8%8C%AB%E7%9A%84%E5%A4%A7%E4%B8%80%E5%A4%A7%E4%BA%8C/"},{"title":"指针到底是个什么鬼,怎么用","text":"学数据结构时，创建链表，他定义了个二级指针，很懵逼，所以就有了这篇博客。指针的 * 有啥用? 在我看来就像打排位匹配对手一样，什么样的段位匹配什么样的对手。就比如我是黑铁4，就匹配不到最强王者。 了解你定义的变量，是怎么来的:首先我们来看基本数据类型，int a = 100, a在内存中，是怎么保存的呢，首先开辟一个内存，地址如：0X61，然后他代表的值是100。 然后再来看 一级指针变量 int *p1 = &amp;a,我们首先还是需要去内存中开辟一个空间，然后假如 p1这个指针的值是 0X62 ，然后注意了，我们也给p1这个指针，赋值了的，所以他就指向 a 的地址: 0X61。 最后就是二级指针变量了， int **p2 = &amp;p1， 如上，**p2的地址值为 0X63，他指向的值就应该是 p1的地址值 。 如下图: 总结一下：这时候你应该悟了，其实每个变量(无论是指针变量还是基本数据类型)都应该有两个值,一个是自己的地址值，一个是装(储存)的值，只不过基本类型和指针装的不一样，一个装数据，一个装地址。 对于int a来说，他的地址是0X61，他装的是100，而对于一级指针int p1来说，他的地址是0X62，而他装的是 a的地址0X61，对于int *p2来说，他的地址是0X63，而他装的是 *p1的地址 0X62; 柯南时间到:现在就来揭秘，指针前面那个 * 有啥用(我们要知道这玩意有啥用，最有利的证据，就是用代码输出结果)： 123456789101112#include &lt;stdio.h&gt;int main(){ int a =100; int *p1 = &amp;a; int **p2 = &amp;p1; int ***p3 = &amp;p2; printf(\"%d, %d, %d, %d\\n\", a, *p1, **p2, ***p3); printf(\"&amp;p2 = %#X, p3 = %#X\\n\", &amp;p2, p3); printf(\"&amp;p1 = %#X, p2 = %#X, *p3 = %#X\\n\", &amp;p1, p2, *p3); printf(\" &amp;a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\\n\", &amp;a, p1, *p2, **p3); return 0;} 运行结果： 1234100, 100, 100, 100&amp;p2 = 0X28FF3C, p3 = 0X28FF3C&amp;p1 = 0X28FF40, p2 = 0X28FF40, *p3 = 0X28FF40&amp;a = 0X28FF44, p1 = 0X28FF44, *p2 = 0X28FF44, **p3 = 0X28FF44 我们从结果，再结合书上讲的，就精炼一下嘛，&amp;表示取取变量的地址符号，*则表示取值符号,。 想要获取指针指向的数据时，一级指针加一个*，二级指针加两个*，三级指针加三个*,以次类推。 而如果指针少一个*，就表示,指针指向数据的地址值。 而指针不加 *，就表示自己储存的什么值(你看a是不是就为100，100就是他储存的值嘛)。 结合这个图来看: 我二级指针，有两个*，就直接可以指到a装的数据了，而少了一个*就代表指向a的地址值(即指向的p1储存的值)。那再少一个就只能指到自己了嘛,那不就是自己储存的p1的地址值吗。 由此我们可以发现，指针的*就像一个打排位，什么样的段位匹配什么样的段位，几个*就指向那个值。 推荐阅读:http://c.biancheng.net/view/2016.html","link":"/2024/01/06/%E6%8C%87%E9%92%88%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC,%E6%80%8E%E4%B9%88%E7%94%A8/"},{"title":"求n个最小公倍数","text":"题目如果两个数很大，怎样求最大公约数，最小公倍数？如果是n个数呢？比如1000个数的最小公倍数 输入2 4 6 3 2 5 7 输出1270 思路首先最大公约数可以用辗转相除法，定义为lcm(m,n)，然后再定义一个方法gcd(m,n)求最大公约数，用公式法 ：最小公倍数 = m * n / lcm(m,n),使用一个数组nums来装输入的数据，大小n由输入决定int nums[] = new int[n];,然后在使用一个while循环，来输入装进数组nums的数据。最后定义一个int a，储存gcd(m,n)参数中的m。 不知道辗转相除法，可以看我的这篇博客，详细介绍了的，很简单。 代码1234567891011121314151617181920212223242526272829303132333435363738public class Test4 { public static void main(String[] args) { int i = 0,m; Scanner sc = new Scanner(System.in); int n = sc.nextInt();//输入要输的个数 int nums[] = new int[n]; while (n != 0 ){ m = sc.nextInt(); if (m == 0){ }else{ nums[i] = m; i++; } n--; } int a =nums[0];//lcm的第一个参数// System.out.println(Arrays.toString(nums)); for (int j = 1 ; j &lt; nums.length; j++){ a = gcd(a,nums[j]); } System.out.println(\"他们的最小公倍数=\"+a); } //求最大公因数 public static int lcm(int m,int n ){ int left = (m &gt; n)? m : n; //左边是较大的数 int right = (m &gt; n)? n : m; //右边是较小的数 if ((left % right) == 0){ return right; } return lcm(right , left % right); } //求最小公倍数 public static int gcd(int m,int n){ return m * n /lcm(m , n); }}","link":"/2024/01/06/%E6%B1%82n%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"},{"title":"看不懂辗转相除法求最小公约数？以身相许那种哦！","text":"给你打个比喻吧：你英雄救美了，美女想要报答你，你想要1000块感谢费，但是美女却想要以身相许😁，懂了吧，同样都是报答，只是用了不一样的方式，辗转相除法也是这样，你两个数的最大公约数不容易求，我就用另外两个简单的数来解决。 废话不多说，看定理。 定理：辗转相除 可以求最大公约数，顾名思义，反复的除，最终得到两数的最大公约数。首先我们来分析下定理： 定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。最大公约数（Greatest Common Divisor）缩写为GCD。gcd(a,b) = gcd(b,a mod b) (不妨设a&gt;b 且r=a mod b ,r不为0) 文字不好理解，举个实例：134 / 18 = 7 … 818 / 8 = 2 … 28 / 2 = 4 … 0 看清了吧，是不是和定理一模一样，所以我们要找最大公约数，而134 /18的和8 / 2的最大公约数相等，所以我们只需要求出8 / 2的最大公约数，是不是就是开头说的换了两个数再求，而我们要知道，因为两数相除，余数为0，其除数必定为最大公约数，所以这里的2也就是我们要找的138 / 18 的最大公约数。至于证明，百度搜索，都有。主要证明思路就是，有a/b余r一式， 先假设y为a，b的公约数，再证明b,r的公约数也为y。 思路：通过定理我们知道，要计算两数最大公约数，我们只需要一直递归就行了，直到余数为0，最大公约数就是较小的那个数（除数）。递归相信大家都了解过吧，必定有一出口，保证程序停止或返回，那么这里的出口条件就是上面例子的2，即余数为0。程序就是先找出输入参数谁打谁小，再判断余数是否为0（出口），再递归。代码用java写的，其实没啥差别，也没用api，思路都一样，格式不一样罢了。 代码：所以我们开始写代码了： 12345678910111213141516private static void method4(int m, int n, int ji) { //相比较两个数，把较小的那个数赋值给smallNum; int smallNum = (m &gt; n ? n:m); int bigNum = (m &gt; n ? m:n); if ( n &lt; 0 || m &lt; 0 ){ System.out.println(\"输入有错，结束了\"); }else{ //余数为0，smallNum就是那个最大公约数 if (bigNum % smallNum == 0){ System.out.println(\"最小公倍数\"+(ji / smallNum)+\" 最大公约数\"+smallNum); //我写了几种方法，方便调用，所以返回的空 return; } method4(smallNum,bigNum % smallNum, ji); } } 通过定理我们知道较小数为除数吧，所以我们直接每次递归时，就把较小那个值找出来。然后把它变成除数，不就行了吗。 什么你还没学递归，不要紧，我还有一种方法，就是while循环，while循环就不用判断谁大谁小了，因为小数%大数=小数本身，代码搞起来： 1234567891011121314private static void method2(int m ,int n,int ji) { while(true){ if ((m = m % n) == 0){ System.out.println(\"最大公约数\"+n); System.out.println(\"最小公倍数\"+(ji / n)); System.exit(0); } if ((n = n % m) == 0) { System.out.println(\"最大公约数\"+m); System.out.println(\"最小公倍数\"+(ji / m)); System.exit(0); } } } 其实我还有一种枚举的算法，就不写了。当然求解最大公倍数，辗转相除还不是最优，还有更优，大家可以搜搜看。如果有时间，我在补充其他的算法。","link":"/2024/01/06/%E7%9C%8B%E4%B8%8D%E6%87%82%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%9F%E4%BB%A5%E8%BA%AB%E7%9B%B8%E8%AE%B8%E9%82%A3%E7%A7%8D%E5%93%A6%EF%BC%81/"},{"title":"模拟B,S服务器","text":"最近学到了网络编程，有个练习：模拟B\\S服务器 模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。踩了两个坑，就是： ①HTTPS，不能用这个协议，来访问，因为这玩意是加密了的，一开始我还以为它传的不是UTF-8，因为我用的IDEA，默认UTF-8，我还用InputStreamReader去转换，但是发现没法，后来，突然想起了，HTTPS是加密的，然后用HTTP试了，就可以了。 ②网站输入的地址，可以用绝对路径，也可用相对路径，相对路径是相对于我们写的服务端类的项目位置比如我的服务端： 我们的地址就要这样输入： http://localhost:8888/Advanced/src/Net/BSTCP/web/index.html 注意事项： ①这个是HTTP的响应头是固定的格式，需要注意：Http响应头要固定： ②谷歌看不了，建议换其他浏览器看。12345// 写入HTTP协议响应头,固定写法 os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); os.write(\"Content‐Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 os.write(\"\\r\\n\".getBytes()); 写代码思路 客户端是网站，我们只写服务端 需要写两个服务端，一个是向客户端发送html代码，一个是发送图片 建立连接时，需要使用HTTP协议，而不能使用HTTPS协议，这个协议被加密了，所以客户端只能输出加密的请求头。 服务端的执行步骤： 先创建ServerSocket，监听请求，接收到了，就使用accept( )捕获。 利用网络输入流，读取客户端请求头，然后获取Get请求，其中的文件地址。 处理地址格式 使用本地文件流，读取文件，并向客户端输出 在创建一个传输照片的服务端，与传输html的服务端代码几乎一样，差别在于，传输照片服务端，要一直监听请求，因为他传输的不是一张照片 优化：&lt;font color=red&gt;使用多线程，加快传输效率&lt;/font&gt; 下面放出全部代码：html服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.io.*;import java.net.ServerSocket;import java.net.Socket;//http://localhost:8888/Advanced/src/Net/BSTCP/web/index.html HTTP/1.1//不能使用https，加密协议public class Server { public static void main(String[] args) throws IOException { System.out.println(\"服务端启动，等待连接。。。。\"); //创建一个服务器ServerSocket,和系统要指定的端口号 ServerSocket server = new ServerSocket(8888); //使用accept方法获取到请求的客户端对象(浏览器) Socket socket = server.accept(); //使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //输出客户端的请求 /*byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes,0,len)); System.out.println(\"cao\");*/ //把is字节流，转换成字符流，并且使用缓冲流读取 BufferedReader br = new BufferedReader(new InputStreamReader(is)); //读取第一行GET请求的内容 String s = br.readLine(); //按空格把它分开 String[] s1 = s.split(\" \"); //把前面的\"/\"给排除，使用字符串的截取 String path = s1[1].substring(1); System.out.println(path); //创建一个fis流，读取本地的index.html文件 FileInputStream fis = new FileInputStream(path); //获取网络输出流OutputStream，向客户端输出页面 OutputStream os = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); os.write(\"Content‐Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 os.write(\"\\r\\n\".getBytes()); //向客户端输出 byte bytes[] = new byte[1024]; int len = 0; while((len = fis.read(bytes))!=-1){ os.write(bytes); } //关闭资源 fis.close(); br.close(); socket.close(); }} 照片服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class ImageServer { public static void main(String[] args) throws IOException { System.out.println(\"服务端启动，等待连接。。。。\"); //创建一个服务器ServerSocket,和系统要指定的端口号 ServerSocket server = new ServerSocket(8888); while (true){ //使用accept方法获取到请求的客户端对象(浏览器) Socket socket = server.accept(); //使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //输出客户端的请求 /*byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes,0,len)); System.out.println(\"cao\");*/ //多线程，加快传输速度 new Thread(new Runnable() { @Override public void run() { try{ //把is字节流，转换成字符流，并且使用缓冲流读取 BufferedReader br = new BufferedReader(new InputStreamReader(is)); //读取第一行GET请求的内容 String s = br.readLine(); //按空格把它分开 String[] s1 = s.split(\" \"); //把前面的\"/\"给排除，使用字符串的截取 String path = s1[1].substring(1); System.out.println(path); //创建一个fis流，读取本地的index.html文件 FileInputStream fis = new FileInputStream(path); //获取网络输出流OutputStream，向客户端输出页面 OutputStream os = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); os.write(\"Content‐Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 os.write(\"\\r\\n\".getBytes()); //向客户端输出 byte bytes[] = new byte[1024]; int len = 0; while((len = fis.read(bytes))!=-1){ os.write(bytes); } //关闭资源 fis.close(); br.close(); socket.close(); }catch (IOException e){ e.printStackTrace(); } } }).start(); } }}","link":"/2024/01/06/%E6%A8%A1%E6%8B%9FB,S%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"组合算法","text":"在数学中，我们学习了，排列组合，排列是有序的，组合是无顺序的。在做算法题时，我们也会遇到这种。so，今天来理下，怎么写组合。 举个例子，桌子上有3个球A,B,C，我们取2个，无放回的取，有几种情况？算一下：也就是C(3,2)=3。 需要解决的问题那么先理下思路，我们需要解决哪几个问题： 要怎么表示3个数是否被取了呢，我想，弄一个int数组把他们的初值置为0，就像int a = {0,0,0},如果他被取了，就把它置为1，三个int分别代表ABC。 然后就是从箱子里取球,是组合是吧。 最后，满足条件，输出我们得到的组合。 方案第一步，我们已经解决了，怎么表示球被取出来了。第二步，组合：我们想下，以下场景： 从桌子上取A，那么就是BC求组合，取B，就是AC求组合，取C，就是AB求组合 继续重复，求BC的组合，就是取B出来，求C的组合，再像这样继续套娃。。。。都是调用的同一个方法，可想而知，是一个递归。 那么定义一个函数，它的作用是从a中取球，取到满足条件输出组合。再定义一个index，表示我取得是哪一个球。之后，我们取球，如果要选，把a[index]置为1，参数curr表示已经取了多少个球，所以也需要+1，然后再去取下一个球。如此反复。 当然我们也可以不取这个球，不取这个球，就要把它置为0，但是需要index++，因为不取这个球，那还是需要去取下一个球，比如不取A，但是我们还是要去BC。 紧接着找到递归出口，也就是取完2个球，或者3个球都被取完了。得到之后，就把它打印出来。也就是调用show(a[])方法。 show方法:遍历i数组，如果a[i]==1，即我们取了，就把他输出。(char)('A'+i)+&quot; &quot;这也是个小细节。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*从5个小球中取出三个小球*/public class 组合 { static int count; //很明显是一个组合问题,不用考虑排列，排列的话，就可以用全排列 public static void main(String[] args) { int a[] = {0,0,0}; method1(a,0,2,0); System.out.println(count); } /** * 作用: 从a中取球，取到2个球有哪几种组合 * * @param a 数组a表示当前被选中的数 * @param index 当前被选中的数的索引 * @param sum 要选中多少个数 * @param curr 当前已经选中了多少个数 */ private static void method1(int a[], int index, int sum, int curr) { if (curr == sum){ show(a); count++; return; } //如果数组都选完了，就不能选了,之所以index == a.length，是因为最后一个也要被选 if (index == a.length){ return; } //当前位置要选，将这个位置改为1 a[index] = 1; //判断下一个数是否要选 method1(a,index+1,sum,curr+1); //当前这个位置不选，将这个位置改为0 a[index] = 0; method1(a,index+1,sum,curr); } private static void show(int[] a) { for (int i =0; i &lt; a.length;i++){ if (a[i] == 1 ){ System.out.print((char)('A'+i)+\" \");//变成char与int相加为int，所以再把它变成char } } System.out.println(); }}","link":"/2024/01/06/%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95/"},{"title":"用Hexo+gitHub Pages生成一个静态网页","text":"如何用Hexo+Github Pages快速搭建自己的博客保姆级教程本文章快速搭建博客，有一个前提，那就是对git有所了解，如果你对git的使用即原理很熟悉的话，那么这个博客搭建就会很快，不超过一个小时。当然你下载资源很慢，就当我没说，嘻嘻。当然如果你不了解，也没关系，凡事都是从0开始的，我也会在文中讲解的，废话少说，开始！ 温馨提示1.首先要知道搭建网站你的目的是什么，有动力，才有坚持下去的勇气，也才会有拨开云雾见太阳的高兴(博客搭建好的时候)。 2.资源下载慢是很大的问题，下面会解答。 3.如果你github网站访问速度巨慢，建议谷歌或者百度，毕竟面向谷歌编程嘛,哈哈哈。 文章导读1.介绍要下载的东西2.安装3.搭建4.原理解释（之所以放在最后，是给自己总结，明白其原理，回过头才会理解更深,当然后面美化博客，也需要知道大概原理。） 1.介绍工具，安装的东西如果不耐烦，可以直接跳过到安装步骤。1.git：按我自己的理解，git可以再我们的电脑上创建一个本地仓库（在这就是我们的博客仓库），然后把我们的网页部署到github上的github Pages上。2.node.js:不安装这玩意，就没法玩。因为他要安装Hexo。3.Hexo：这个东西可以把我们本地的Markdown文件，后缀.md的文件，处理，渲染，然后变成静态网页，也就是我们的博客。所有看官们知道了吧，慢慢安装吧，不安装好，博客就凉凉了。 2.安装工具（1）安装Node.js这个玩意推荐大家去官网下载，网不好建议下载个火狐浏览器。进入官网，直接选自己是多少位的就行。不知道的到我的电脑去看。我选的windows 64-bit。 （2）安装git这个也是Git官网下载，跟上面一样，选择对应的版本下载即可。下载好了就安装，安装一直next就行，然后cmd里git version，有版本号就成功了。然后去桌面有键就有下面两个git了。上面那个是图形化管理工具，由于做的比较丑，我们还是选用下面的命令行来操作。 （3）安装主角Hexo由于Hexo这玩意是托管在国外的，所以啊，下载会巨慢，所以我们就用国内的淘宝镜像。在cmd中输入以下： 12npm config set registry https://registry.npm.taobao.orgnpm config get registry//**这个是用来检查换成功没** 安装Hexo 1npm install hexo-cli -g 安装hexo的一个相当于命令的东西吧。后面原理会讲。 1npm install hexo-deployer-git --save 第二句是安装hexo部署到git page的deployer 换好镜像，安装好Hexo，搭建博客的前戏就完了，可以喝杯咖啡，起来走走，劳逸结合嘛。 3.搭建博客这个部分，如果网速好，很快就完事了，网速不好，就静静等吧。 （1）初始化博客首先自己选个地方，创建一个文件夹，来装我们博客的主体。比如F:\\Projects\\blog，文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。这里是最耗时间的了，因为主题，资源比较多，下载会很慢，不过，只要是网速问题，我们都能解决，就是通过换淘宝镜像，提高速度。其他的不懂谷歌呀，哈哈。初始化好之后，一个崭新的博客出现在了我们眼前。这时候，再bush中输入 1hexo s 直接网页搜索localhost:4000，你的博客雏形就出来了。这TM才叫功夫不负有心人。当然这只是你本地仓库的博客，我们写博客不就是为了装B吗，不让别人看见，那能叫装B吗？下贱，哈哈哈！开玩笑，写博客肯定是提升自己呀，怎么扯到装B上了。 （2）github的使用敲黑板！！！重点来了！！！部署博客到GIthub - Pages，文章开头不是说了吗，如果你了解git那么，这部分，你可以略过，小白们还是来学下。 首先，注册个github账号吧，总不可能，用别人东西，还不给别人增加流量吧，拒绝白嫖，嘻嘻嘻，搭建好点赞你懂得！！！！ 进入正题，其实不要把github想的很难，主要是英文把你难着了吧，哈哈哈，如果英语差可以谷歌浏览器翻译。 github其实就是个托管代码的，我们在这上面建库，然后把代码push上来，当然我们的博客不用push上来，后面讲解原理。 （3）配置SSH钥匙：SSH是个协议，就像HTTPS一样，保证安全的。我们要把项目托管上去，github需要知道一把钥匙，这是公钥，我们自己有一把钥匙，叫私钥。下面配置：1.创建钥匙： 1234 $ ssh-keygen -t rsa -C \"your_email@example.com\"#这将按照你提供的邮箱地址，创建一对密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 然后钥匙的位置在用户文件下，叫做 .ssh,有个后缀是pub的，这个就是公钥，私钥是另一把，把公钥的内容复制下来，到github，点你的头像，有个setting，设置里去配置公钥。 好了配置好公钥了，下面检查一下 1$ ssh -T git@github.com 123The authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 输入yes就好了，下面就要设置用户信息了 12$ git config --global user.name \"github名字\"//用户名$ git config --global user.email \"github注册的邮箱\"//填写自己的邮箱 下面点击的你新建的仓库，有个：复制你的项目地址，到Hexo的配置文件里：就是找到deploy（部署），开始只有个type的，加上我写的，只用改repository就行了，branch不用改： 1234deploy: type: git repository: git@github.com:chenQD123/chenQD-blog.git branch: master 记住这有个坑， 就是冒号后面有个空格，这是规定，如果没写空格，后面会部署失败，这就像python一样。然后就是美汁汁的部署你的博客到github上。 123在Hexo里，hexo generate -deploy生成+部署 如果报错：说明最开始让你安装的deploy没成功，所以在安装一次就行了，他也有提示（会让你安装），如下： 1ERROR Deployer not found: git 只需要安装好即可 1npm install hexo-deployer-git --save （4）部署博客好了，结束了，看到这里，你的博客就部署完成了，这时候你的博客，别人就能看见了，只需要在任何一个浏览器输入：你的项目名，比如我就是：https://chenqd123.github.io/，这也是github给我们的公开地址，不如说是github Pages给的。就是github pages帮我们托管的博客。 （5）美化博客如果想使自己的博客好看点可以换主题：Hexo官网主题建议换个，使用者多点的主题，这种的说明文档写的比较好，你开荒也会容易点。 4.实现原理首先来介绍为Hexo：Hexo是Node.js在github开源的快速开发博客的一个框架。那么Hexo究竟怎么帮助我们实现的呢，这里说一下大概原理，我们开始安装Hexo，是通过 1npm install hexo-cli -g 安装好之后，我们通过hexo+命令这样的方式来操作Hexo的一些插件，就比如：hexo server、hexo generate。当执行hexo server时，Hexo的Markdown文档会进行两次渲染，变成我们的博客。1.第一次是遍历我们的根目录下的source文件，就是我们博客的页面，他会输出一些article对象，就是我们每个页面等。2.hexo generate第二次渲染会遍历我们themes下的文件，这个文件下的内容，是我们美化要修改的地方，他会输出根目录下的public文件夹。这个public是我们要托管到github上的博客，当我们hexo deploy完成，就会把我们的博客push，部署到github上，每个github账号都会有一个站点，并且有无限的项目站点。而github pages 就是来托管我们的页面的，通过这个github pages给我们的域名来访问我们的博客，我们每次修改博客时，也只是提交的public文件，hexo generate产生、hexo deploy部署的页面。 结语写到这了。文章到这里就结束了，第一次写这么长的博客，有错请纠正！如果对你有帮助，点赞点赞，码了这么多的字，没有功劳也有苦恼呀，呜呜呜（撕心裂肺）。","link":"/2020/07/22/%E7%94%A8Hexo-gitHub-Pages%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/"},{"title":"罗马数字转十进制的三种方法","text":"题目要求 古罗马帝国开创了辉煌的人类文明，但他们的数字表示法的确有些繁琐，尤其在表示大数的时候，现在看起来简直不能忍受，所以在现代很少使用了。 之所以这样，不是因为发明表示法的人的智力的问题，而是因为一个宗教的原因，当时的宗教禁止在数字中出现0的概念！罗马数字的表示主要依赖以下几个基本符号：I –&gt; 1V –&gt; 5X –&gt; 10L –&gt; 50C –&gt; 100D –&gt; 500M –&gt; 1000这里，我们只介绍一下1000以内的数字的表示法。单个符号重复多少次，就表示多少倍。最多重复3次。比如：CCC表示300 XX表示20，但150并不用LLL表示，这个规则仅适用于I X C M。如果相邻级别的大单位在右，小单位在左，表示大单位中扣除小单位。比如：IX表示9 IV表示4 XL表示4049 = XLIX更多的示例参见下表，你找到规律了吗？I = 1II = 2III = 3IV = 4V = 5VI = 6VII = 7VIII = 8IX = 9X = 10XI = 11XII = 12XIII = 13XIV = 14XV = 15XVI = 16XVII = 17XVIII = 18XIX = 19XX = 20XXI = 21XXII = 22XXIX = 29XXX = 30XXXIV = 34XXXV = 35XXXIX = 39XL = 40L = 50LI = 51LV = 55LX = 60LXV = 65LXXX = 80XC = 90XCIII = 93XCV = 95XCVIII = 98XCIX = 99C = 100CC = 200CCC = 300CD = 400D = 500DC = 600DCC = 700DCCC = 800CM = 900CMXCIX = 999本题目的要求是：请编写程序，由用户输入若干个罗马数字串，程序输出对应的十进制表示。输入格式是：第一行是整数n,表示接下来有n个罗马数字(n&lt;100)。以后每行一个罗马数字。罗马数字大小不超过999。要求程序输出n行，就是罗马数字对应的十进制数据。例如，用户输入：3LXXXXCIIIDCCII则程序应该输出：8093702 解法全在程序里，分为三个方法，三个方法由易到难。但全是暴力求解法。 直接找出组成相减的字符串，先把加法算完，再算减法。 遍历字符串，根据它的转换规则 相邻的罗马数字相加。 相邻的罗马数字，左边小于右边的数字，等于右 - 左。 思路和法二一样，但是算法上简洁了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import java.util.*;/*本题目的要求是：请编写程序，由用户输入若干个罗马数字串，程序输出对应的十进制表示。 输入格式是：第一行是整数n,表示接下来有n个罗马数字(n&lt;100)。 以后每行一个罗马数字。罗马数字大小不超过999。 要求程序输出n行，就是罗马数字对应的十进制数据。*/public class Test3 { public static void main(String[] args) { method1(\"XCV\");// method2(\"XCV\");// method3(\"XCV\"); } //直接找出组成相减的字符串 private static void method1(String lm) { int sum =0; //遍历字符串，如果存在则加 for (int i = 0; i &lt; lm.length(); i++) { char c = lm.charAt(i); if (c == 'I') sum += 1; if (c == 'V') sum += 5; if (c == 'X') sum += 10; if (c == 'L') sum += 50; if (c == 'C') sum += 100; if (c == 'D') sum += 500; if (c == 'M') sum += 1000; } //indexOF(V)返回改子字符串的索引 if (lm.indexOf(\"IV\")&gt;=0) sum -= 2; if (lm.indexOf(\"IX\")&gt;=0) sum -= 2; if (lm.indexOf(\"XL\")&gt;=0) sum -= 20; if (lm.indexOf(\"CD\")&gt;=0) sum -= 200; if (lm.indexOf(\"CM\")&gt;=0) sum -= 200; if (lm.indexOf(\"XC\")&gt;=0) sum -= 20; System.out.println(sum); } //把他们放在键值对里（HashMap），挨个遍历 private static void method2(String lm) { //给罗马数字赋值 Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); //把数字分成数组 //十进制的值 int sum = 0; char[] chars = lm.toCharArray(); //循环字符数组，从右往左, for (int i = chars.length-1; i &gt;= 1; i--) { //最好是改变i的初值，而不是改变索引 //当前的值 int cur = map.get(chars[i]); //前一个的值 int left = map.get(chars[i - 1]); //如果当前值大于左，则相减 //如果为第一次，则需要改变公式 if (i == chars.length-1){ if (left &lt; cur){ sum = sum + cur - left; }else { sum = sum +cur+ left; } }else{ if (left &lt; cur){ sum = sum - left; }else { sum = sum + left; } } } System.out.println(sum); } //同法二思路一样的，但是做了算法简化 private static void method3(String lm) { HashMap&lt;String, Integer&gt; map=new HashMap&lt;String, Integer&gt;(); map.put(\"I\", 1); map.put(\"V\", 5); map.put(\"X\", 10); map.put(\"L\", 50); map.put(\"C\", 100); map.put(\"D\", 500); map.put(\"M\", 1000); int result=0; for(int i=0;i&lt;lm.length();i++){ //只算除最后一位的前面的数 if(i &lt;= lm.length()-2){ //+\"\"的作用是变成字符串，因为我Map键为String类型 //如果左边小于右边，则减，并且i再加+1，跳到下两个，否则则每次只加一位 if(map.get(lm.charAt(i)+\"\") &lt; map.get(lm.charAt(i+1)+\"\")){ result += (map.get(lm.charAt(i+1)+\"\")-map.get(lm.charAt(i)+\"\")); i++; }else{ result += map.get(lm.charAt(i)+\"\"); } //最后一位直接加 }else{ result += map.get(lm.charAt(i)+\"\"); } } System.out.println(result); }}","link":"/2024/01/06/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"进制转换","text":"题目：用天平称重时，我们希望用尽可能少的砝码组合称出尽可能多的重量。 如果只有5个砝码，重量分别是1，3，9，27，81 则它们可以组合称出1到121之间任意整数重量（砝码允许放在左右两个盘中）。 本题目要求编程实现：对用户给定的重量，给出砝码组合方案。例如：用户输入：5程序输出：9-3-1用户输入：19程序输出：27-9+1 要求程序输出的组合总是大数在前小数在后。可以假设用户的输入的数字符合范围1~121。 思路：观察输出，都是3的多少次方，所以我们可以把输入的值，转换成3进制的数,因为3进制转10进制 每一项都是ai*3^n,就满足题目的要求了，就比如 4 = 1*(3^1) +1*(3^0) =3+1 ，但是 5 使用除K取余法时，会余2，我们不能余2， 因为，每一项的系数ai都应该为 0 或 1 或 -1，所以在除k取余，我们只要把余数2变成-1，就行了。 代码：123456789101112131415161718192021222324252627282930313233public class Test2 { public static void main(String[] args) { String weight = JOptionPane.showInputDialog(\"请输入重量\"); balance(weight); } private static void balance(String w) { //n为当前被除数 int n = Integer.parseInt(w); ArrayList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); int i = 0; while (n != 0){ nums.add(i,n % 3); n = n / 3; if (nums.get(i) == 2){ //替换当前位置的数 nums.set(i,-1); n += 1; } i++; } System.out.println(nums); for (int j = nums.size() - 1 ; j &gt;= 0; j--){ if (nums.get(j) &lt; 0 || j == nums.size()-1){ System.out.print((int)Math.pow(3,j)*nums.get(j)); } else if (nums.get(j) == 0){ } else{ System.out.print(\"+\"+(int)Math.pow(3,j)*nums.get(j)); } } }}","link":"/2024/01/06/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"}],"tags":[{"name":"IO","slug":"IO","link":"/tags/IO/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"MySql","slug":"MySql","link":"/tags/MySql/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"shiro","slug":"shiro","link":"/tags/shiro/"},{"name":"thymeleaf","slug":"thymeleaf","link":"/tags/thymeleaf/"},{"name":"ssm","slug":"ssm","link":"/tags/ssm/"},{"name":"tomcat","slug":"tomcat","link":"/tags/tomcat/"},{"name":"servlet","slug":"servlet","link":"/tags/servlet/"},{"name":"枚举法","slug":"枚举法","link":"/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"},{"name":"谷歌","slug":"谷歌","link":"/tags/%E8%B0%B7%E6%AD%8C/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"全排列","slug":"全排列","link":"/tags/%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","link":"/tags/%E5%8A%9B%E6%89%A3/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"时间复杂度","slug":"时间复杂度","link":"/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","link":"/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"组合","slug":"组合","link":"/tags/%E7%BB%84%E5%90%88/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Github Pages","slug":"Github-Pages","link":"/tags/Github-Pages/"},{"name":"进制转换","slug":"进制转换","link":"/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"ssm","slug":"java/ssm","link":"/categories/java/ssm/"},{"name":"C语言","slug":"C语言","link":"/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"谷歌","slug":"工具/谷歌","link":"/categories/%E5%B7%A5%E5%85%B7/%E8%B0%B7%E6%AD%8C/"},{"name":"递归","slug":"算法/递归","link":"/categories/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"},{"name":"枚举","slug":"算法/枚举","link":"/categories/%E7%AE%97%E6%B3%95/%E6%9E%9A%E4%B8%BE/"}]}